<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Graveyard Shooter - Bright Version</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background-color: #111; }
        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); /* 背景半透明度降低 */
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: #ffffff; z-index: 999;
        }
        #instructions { font-size: 30px; cursor: pointer; text-align: center; text-shadow: 2px 2px 4px #000; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #00ff00; /* 改為綠色UI更清晰 */
            font-size: 24px; font-weight: bold; pointer-events: none;
            text-shadow: 2px 2px 4px black;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 24px; height: 24px;
            background: transparent;
            border: 2px solid rgba(0, 255, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: #00ff00;
            transform: translate(-50%, -50%); border-radius: 50%;
        }
        #loading { position: absolute; bottom: 20px; left: 20px; color: yellow; font-weight: bold;}
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
    <div id="ui">
        KILLS: <span id="score">0</span> | HEALTH: <span id="health">100</span>%
    </div>
    <div id="crosshair"></div>
    <div id="loading">正在加載模型... (如果不顯示請刷新)</div>
    
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:50px; letter-spacing: 5px;">獵魔人</p>
            <p>點擊畫面開始 (已開啟手電筒)</p>
            <p>W, A, S, D 移動 | 空白鍵 跳躍 | 滑鼠左鍵 射擊</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, controls;
        let raycaster;
        const clock = new THREE.Clock();
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        
        let enemyUnits = []; 
        let score = 0;
        let health = 100;
        let lastShootTime = 0;
        let playerWeapon;
        let ghostModelTemplate = null;
        let ghostAnimations = null;
        
        const scoreEl = document.getElementById('score');
        const healthEl = document.getElementById('health');
        const blocker = document.getElementById('blocker');
        const loadingEl = document.getElementById('loading');

        // 模型 URL
        const WEAPON_URL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoomBox/glTF-Binary/BoomBox.glb'; 
        const ENEMY_URL = 'https://threejs.org/examples/models/gltf/Soldier.glb'; 

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            // 調整 1: 背景改亮一點的深藍色，不再是純黑
            scene.background = new THREE.Color(0x222233);
            // 調整 2: 霧的濃度從 0.03 降到 0.008，視距大幅增加
            scene.fog = new THREE.FogExp2(0x222233, 0.008); 

            // --- 燈光系統大升級 ---
            
            // 1. 環境光：大幅調亮 (強度 1.2)，顏色改為灰白色
            const ambientLight = new THREE.AmbientLight(0xeeeeff, 1.2);
            scene.add(ambientLight);
            
            // 2. 月光：增強亮度並調整角度
            const moonLight = new THREE.DirectionalLight(0xffffff, 1.5);
            moonLight.position.set(50, 100, 50);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            scene.add(moonLight);

            // 3. 玩家手電筒 (SpotLight)
            // 跟隨玩家視角
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 12;

            const flashlight = new THREE.SpotLight(0xffffff, 50, 200, 0.6, 0.5, 1); // 強光，射程200
            flashlight.position.set(0, 0, 0); // 綁在相機原點
            flashlight.target.position.set(0, 0, -1); // 照向前方
            camera.add(flashlight);
            camera.add(flashlight.target);

            controls = new PointerLockControls(camera, document.body);

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', function () { controls.lock(); });
            controls.addEventListener('lock', function () { instructions.style.display = 'none'; blocker.style.display = 'none'; });
            controls.addEventListener('unlock', function () { blocker.style.display = 'flex'; instructions.style.display = ''; });
            scene.add(controls.getObject());

            // 事件
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);

            createGraveyardEnvironment();

            // 加載資源
            const loader = new GLTFLoader();
            let itemsLoaded = 0;
            function checkLoading() {
                itemsLoaded++;
                if (itemsLoaded === 2) loadingEl.style.display = 'none';
            }

            loader.load(WEAPON_URL, (gltf) => {
                playerWeapon = gltf.scene;
                playerWeapon.scale.set(100, 100, 100); 
                playerWeapon.position.set(1.5, -1.5, -2.5);
                playerWeapon.rotation.y = Math.PI;
                // 使武器稍微亮一點
                playerWeapon.traverse(c => { if(c.isMesh) c.material.emissive = new THREE.Color(0x333333); });
                camera.add(playerWeapon);
                checkLoading();
            }, undefined, (e) => { console.error(e); loadingEl.innerText = "武器加載失敗"; });

            loader.load(ENEMY_URL, (gltf) => {
                const model = gltf.scene;
                ghostAnimations = gltf.animations;
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x88ffff, // 敵人顏色改亮
                            emissive: 0x004444,
                            roughness: 0.1,
                            metalness: 0.8
                        });
                        child.castShadow = true;
                    }
                });
                model.scale.set(7, 7, 7);
                ghostModelTemplate = model;
                checkLoading();
            }, undefined, (e) => { console.error(e); loadingEl.innerText = "敵人加載失敗"; });

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            // 開啟色調映射，防止過曝
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);
        }

        function createGraveyardEnvironment() {
            // 地面顏色調亮
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            floorGeometry.rotateX(- Math.PI / 2);
            const positionAttribute = floorGeometry.attributes.position;
            for ( let i = 0; i < positionAttribute.count; i ++ ) {
                 if (positionAttribute.getY(i) === 0) positionAttribute.setY( i, Math.random() * 2); 
            }
            floorGeometry.computeVertexNormals();

            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333, // 淺灰色地面
                roughness: 0.8,
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.receiveShadow = true;
            scene.add(floor);

            // 墓碑顏色調亮
            const tombGeo = new THREE.BoxGeometry(4, 8, 2);
            const tombMat = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.5 }); // 亮灰色墓碑
            
            const treeGeo = new THREE.ConeGeometry(3, 20, 5);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31, roughness: 1 }); // 棕色樹木

            for (let i = 0; i < 150; i++) {
                const tomb = new THREE.Mesh(tombGeo, tombMat);
                tomb.position.x = (Math.random() - 0.5) * 800;
                tomb.position.z = (Math.random() - 0.5) * 800;
                tomb.position.y = 4;
                tomb.rotation.y = Math.random() * 0.5;
                tomb.castShadow = true;
                tomb.receiveShadow = true;
                scene.add(tomb);

                if (i % 5 === 0) {
                     const tree = new THREE.Mesh(treeGeo, treeMat);
                     tree.position.x = (Math.random() - 0.5) * 800;
                     tree.position.z = (Math.random() - 0.5) * 800;
                     tree.position.y = 10;
                     tree.castShadow = true;
                     scene.add(tree);
                }
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump === true) velocity.y += 250; canJump = false; break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseDown(event) {
            if (!controls.isLocked || health <= 0) return;
            const now = performance.now();
            if (now - lastShootTime < 250) return; 
            lastShootTime = now;

            const flash = new THREE.PointLight(0xffff00, 5, 20); // 槍口光更亮
            flash.position.set(1.5, -1, -3);
            camera.add(flash);
            setTimeout(() => camera.remove(flash), 50);
            
            if(playerWeapon) {
                playerWeapon.position.z += 0.2;
                setTimeout(() => { playerWeapon.position.z -= 0.2; }, 100);
            }

            const shootRaycaster = new THREE.Raycaster();
            shootRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const enemyMeshes = enemyUnits.map(u => u.mesh);
            const intersects = shootRaycaster.intersectObjects(enemyMeshes, true);

            if (intersects.length > 0) {
                let hitObject = intersects[0].object;
                while(hitObject.parent && hitObject.parent.type !== 'Scene') {
                    hitObject = hitObject.parent;
                }
                const hitUnitIndex = enemyUnits.findIndex(u => u.mesh === hitObject);
                if (hitUnitIndex > -1) {
                    destroyEnemy(hitUnitIndex);
                }
            }
        }

        function destroyEnemy(index) {
            const unit = enemyUnits[index];
            scene.remove(unit.mesh);
            unit.mixer.stopAllAction();
            enemyUnits.splice(index, 1);
            score++;
            scoreEl.innerText = score;
            
            const geometry = new THREE.IcosahedronGeometry(3, 0);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true }); // 黃色爆炸
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(unit.mesh.position);
            scene.add(explosion);
            let scale = 1.0;
            const animExp = () => {
                scale += 0.2;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.05;
                if (scale < 5) requestAnimationFrame(animExp);
                else scene.remove(explosion);
            };
            animExp();
        }

        function spawnEnemy() {
            if (!ghostModelTemplate || enemyUnits.length > 15) return; 

            const enemyMesh = ghostModelTemplate.clone();
            const mixer = new THREE.AnimationMixer(enemyMesh);
            const clip = ghostAnimations[1] || ghostAnimations[0]; 
            if (clip) {
                const action = mixer.clipAction(clip);
                action.play();
            }

            const angle = Math.random() * Math.PI * 2;
            const radius = 150 + Math.random() * 200;
            enemyMesh.position.x = controls.getObject().position.x + Math.cos(angle) * radius;
            enemyMesh.position.z = controls.getObject().position.z + Math.sin(angle) * radius;
            enemyMesh.position.y = 0; 

            scene.add(enemyMesh);
            enemyUnits.push({ mesh: enemyMesh, mixer: mixer, speed: 20 + Math.random() * 15 });
        }

        function updateGameState(delta) {
            const playerPos = controls.getObject().position;
            
            enemyUnits.forEach((unit, index) => {
                if (unit.mixer) unit.mixer.update(delta);
                const lookAtPos = new THREE.Vector3(playerPos.x, unit.mesh.position.y, playerPos.z);
                unit.mesh.lookAt(lookAtPos); 

                const direction = new THREE.Vector3().subVectors(playerPos, unit.mesh.position);
                const distance = direction.length();

                if (distance > 15) {
                    direction.normalize();
                    unit.mesh.position.add(direction.multiplyScalar(unit.speed * delta));
                } else {
                    health -= delta * 10; 
                    healthEl.innerText = Math.floor(Math.max(0, health));
                    if (health <= 0) {
                        controls.unlock();
                        alert("GAME OVER! Kills: " + score);
                        location.reload();
                    }
                }
            });
            
            if (Math.random() < 0.03 && health > 0) spawnEnemy();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 

            if (controls.isLocked === true && health > 0) {
                velocity.x -= velocity.x * 8.0 * delta;
                velocity.z -= velocity.z * 8.0 * delta;
                velocity.y -= 9.8 * 80.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 450.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 450.0 * delta;

                controls.moveRight(- velocity.x * delta);
                controls.moveForward(- velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 12) {
                    velocity.y = 0;
                    controls.getObject().position.y = 12;
                    canJump = true;
                }
                
                updateGameState(delta);
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>