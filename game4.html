<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Graveyard Shooter - Balanced Horror</title>
    <style>
        /* --- 基礎設定 --- */
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; font-family: 'Segoe UI', 'Courier New', monospace; }
        
        /* --- 全螢幕特效 --- */
        #screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,20,0,0.6) 90%);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
            z-index: 10;
        }
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            z-index: 11; opacity: 0.6;
        }

        /* --- 準心 --- */
        #crosshair-wrapper {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 20;
            display: flex; align-items: center; justify-content: center;
        }
        #crosshair {
            width: 40px; height: 40px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            position: relative;
            transition: all 0.1s;
            box-shadow: 0 0 10px cyan;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: #fff; border-radius: 50%;
        }
        #crosshair.reloading {
            border-color: #ffaa00; border-style: dashed; animation: spin 1s infinite linear;
            width: 60px; height: 60px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* --- UI 容器 --- */
        #hud {
            position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .hud-panel {
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 5px solid cyan;
            padding: 15px;
            backdrop-filter: blur(4px);
            clip-path: polygon(0 0, 100% 0, 100% 85%, 90% 100%, 0 100%);
            color: #fff;
            text-shadow: 0 0 5px cyan;
            transition: all 0.2s;
        }
        .hud-bottom-left { position: absolute; bottom: 30px; left: 30px; width: 300px; }
        .hp-segment { display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 5px; }
        .hud-label { font-size: 12px; color: #aaa; letter-spacing: 2px; }
        .hud-value-big { font-size: 36px; font-weight: bold; line-height: 1; }
        #hp-bar-container { width: 100%; height: 15px; background: #001122; border: 1px solid #004455; transform: skewX(-20deg); overflow: hidden; }
        #hp-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ffff00); box-shadow: 0 0 10px #ff0000; }

        .hud-bottom-right { position: absolute; bottom: 30px; right: 30px; text-align: right; border-left: none; border-right: 5px solid yellow; clip-path: polygon(10% 0, 100% 0, 100% 100%, 0 100%, 0 15%); }
        #ammo-val { font-size: 60px; color: #ffff00; text-shadow: 0 0 15px #ffaa00; }
        #weapon-type { font-size: 14px; color: #ccc; text-transform: uppercase; border-top: 1px solid #555; padding-top: 5px; margin-top: 5px; }

        .hud-top-center { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; }
        .score-box { background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2); padding: 5px 20px; border-radius: 20px; text-align: center; }
        #boss-warning { color: #ff0000; font-weight: bold; font-size: 18px; display: none; animation: pulseWarning 0.5s infinite alternate; }
        @keyframes pulseWarning { from { opacity: 0.5; text-shadow: 0 0 5px red; } to { opacity: 1; text-shadow: 0 0 20px red; } }

        /* --- BOSS UI --- */
        #boss-tracker { position: absolute; top: 0; left: 0; width: 220px; pointer-events: none; display: none; z-index: 25; }
        .boss-hud-inner { border: 2px solid #ff0000; background: rgba(30, 0, 0, 0.8); padding: 10px; position: relative; }
        .boss-hud-inner::before { content: ''; position: absolute; top: -5px; left: -5px; width: 10px; height: 10px; border-top: 2px solid red; border-left: 2px solid red; }
        .boss-hud-inner::after { content: ''; position: absolute; bottom: -5px; right: -5px; width: 10px; height: 10px; border-bottom: 2px solid red; border-right: 2px solid red; }
        .boss-header { display: flex; justify-content: space-between; color: #ff5555; font-size: 12px; font-weight: bold; margin-bottom: 5px;}
        .boss-name { font-size: 16px; color: #ff0000; text-shadow: 0 0 10px red; text-transform: uppercase; font-weight: 900; letter-spacing: 1px;}
        #boss-hp-track-bg { width: 100%; height: 8px; background: #330000; margin-top: 5px; }
        #boss-hp-track-fill { width: 100%; height: 100%; background: #ff0000; transition: width 0.1s linear; }
        #boss-dist { font-size: 10px; color: #fff; text-align: right; margin-top: 2px; }
        #boss-line { position: absolute; top: 100%; left: 50%; width: 2px; height: 30px; background: linear-gradient(to bottom, red, transparent); transform: translateX(-50%); }

        #interactive-msg {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            font-size: 18px; color: #00ffff; text-shadow: 0 0 10px #00ffff;
            background: rgba(0, 20, 40, 0.8); padding: 10px 20px; border: 1px solid cyan;
            display: none; z-index: 30;
        }

        #blocker {
            position: absolute; top:0; left:0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: #ffffff; z-index: 999;
        }
        
        /* --- 難度設定 --- */
        #difficulty-settings {
            position: absolute; top: 20px; left: 20px; z-index: 1000;
            background: rgba(0, 20, 40, 0.8); border: 1px solid cyan; padding: 15px;
            border-radius: 5px; color: white; font-family: monospace;
            display: none; pointer-events: auto;
        }
        #difficulty-settings h3 { margin-top: 0; color: cyan; }
        .difficulty-option { margin: 10px 0; cursor: pointer; padding: 5px 10px; border-radius: 3px; }
        .difficulty-option:hover { background: rgba(0, 255, 255, 0.2); }
        .difficulty-option.selected { background: rgba(0, 255, 255, 0.4); border-left: 3px solid cyan; }
        
        /* --- 音效控制 --- */
        #audio-controls {
            position: absolute; top: 20px; right: 20px; z-index: 1000;
            background: rgba(0, 20, 40, 0.8); border: 1px solid #00ff00; padding: 10px;
            border-radius: 5px; color: white; font-family: monospace;
            display: none; pointer-events: auto;
        }
        .audio-slider { width: 150px; margin: 5px 0; }
        .audio-label { font-size: 12px; color: #aaa; }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      { "imports": { "three": "https://unpkg.com/three@0.154.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/" } }
    </script>
    <script src="js/common/audio-system.js"></script>
</head>
<body>
    
    <div id="screen-overlay"></div>
    <div id="scanlines"></div>
    <div id="interactive-msg">按 [E] 拾取</div>
    <div id="crosshair-wrapper"><div id="crosshair"></div></div>

    <div id="boss-tracker">
        <div class="boss-hud-inner">
            <div class="boss-header"><span>THREAT DETECTED</span><span>Lvl.<span id="boss-lvl-ui">1</span></span></div>
            <div class="boss-name">HELL KEEPER</div>
            <div id="boss-hp-track-bg"><div id="boss-hp-track-fill"></div></div>
            <div id="boss-dist">DIST: 24m</div>
        </div>
        <div id="boss-line"></div>
    </div>
    
    <div id="hud">
        <div class="hud-top-center">
            <div class="hud-panel score-box">
                <span style="font-size:12px; color:#aaa;">SCORE</span><br>
                <span id="score-val" style="font-size:24px; color:#fff;">0</span>
            </div>
            <div id="boss-warning">⚠️ BOSS APPROACHING ⚠️</div>
        </div>
        <div class="hud-panel hud-bottom-left">
            <div class="hp-segment"><span class="hud-label">VITALS</span><span class="hud-value-big"><span id="hp-text">100</span>%</span></div>
            <div id="hp-bar-container"><div id="hp-bar-fill"></div></div>
        </div>
        <div class="hud-panel hud-bottom-right">
            <div class="hud-label">AMMUNITION</div>
            <div id="ammo-val">6</div>
            <div class="hud-label" style="font-size:10px;">RESERVE: <span id="ammo-reserve">36</span></div>
            <div id="weapon-type">Wingman B3</div>
        </div>
    </div>
    
    <div id="difficulty-settings">
        <h3>難度設定</h3>
        <div class="difficulty-option selected" data-level="1">簡單 (新手)</div>
        <div class="difficulty-option" data-level="2">普通 (標準)</div>
        <div class="difficulty-option" data-level="3">困難 (挑戰)</div>
        <div class="difficulty-option" data-level="4">地獄 (專家)</div>
        <p style="font-size: 11px; color: #888; margin-top: 10px;">影響敵人血量、傷害、生成率</p>
    </div>
    
    <div id="audio-controls">
        <div class="audio-label">主音量</div>
        <input type="range" min="0" max="100" value="70" class="audio-slider" id="master-volume">
        <div class="audio-label">音效音量</div>
        <input type="range" min="0" max="100" value="80" class="audio-slider" id="sfx-volume">
        <div class="audio-label">音樂音量</div>
        <input type="range" min="0" max="100" value="60" class="audio-slider" id="music-volume">
        <div style="margin-top: 10px;">
            <button id="audio-toggle" style="background: #00aa00; color: white; border: none; padding: 5px 10px; cursor: pointer;">音效: 開啟</button>
        </div>
    </div>
    
    <div id="blocker">
        <div style="text-align: center; cursor: pointer;" id="start-btn">
            <h1 style="color:red; font-size:60px; margin:0; text-shadow: 0 0 20px red;">GRAVEYARD PROTOCOL</h1>
            <p style="font-size: 20px; color: cyan;">點擊畫面啟動系統</p>
            <br>
            <div style="border: 1px solid #555; padding: 20px; background: rgba(255,255,255,0.1);">
                <p>WASD 移動 | 空白鍵 跳躍 | R 換彈 | <b>E 拾取</b></p>
                <p style="color: #ff5555;">幽靈出沒時，畫面將毫無徵地閃爍不定</p>
                <p style="color: #00ffff; font-size: 14px; margin-top: 10px;">
                    <b>新功能:</b> 按 [F1] 顯示難度設定 | [F2] 顯示音效控制
                </p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 變數宣告 ---
        let camera, scene, renderer, controls;
        let raycaster;
        const clock = new THREE.Clock();
        
        const player = {
            hp: 100, maxHp: 100,
            ammo: 6, maxMag: 6, reserveAmmo: 24, 
            damage: 45, isSuperWeapon: false, 
            canShoot: true, isReloading: false,
            score: 0,
            difficultyLevel: 1 
        };
        
        // 難度設定
        const difficultySettings = {
            1: { name: "簡單", enemyHealth: 0.7, enemyDamage: 0.5, spawnRate: 0.5, bossHealth: 0.7 },
            2: { name: "普通", enemyHealth: 1.0, enemyDamage: 1.0, spawnRate: 1.0, bossHealth: 1.0 },
            3: { name: "困難", enemyHealth: 1.5, enemyDamage: 1.5, spawnRate: 1.5, bossHealth: 1.5 },
            4: { name: "地獄", enemyHealth: 2.0, enemyDamage: 2.0, spawnRate: 2.0, bossHealth: 2.0 }
        };
        
        // 音效系統
        let audioSystem = null;

        let bossState = { active: false, unit: null, nextSpawnScore: 400, count: 0 };
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let lastStepTime = 0; 
        
        let enemyUnits = []; 
        let dropItems = []; 
        let focusItem = null; 
        let lastShootTime = 0;
        let playerWeaponGroup; 
        
        // 材質
        let floorMaterial, stoneMaterial, woodMaterial, ammoMat, weaponDropMat;
        
        // 槍枝材質
        const matSilver = new THREE.MeshStandardMaterial({color: 0xcccccc, roughness: 0.3, metalness: 0.8});
        const matWhite = new THREE.MeshStandardMaterial({color: 0xffffff, roughness: 0.5, metalness: 0.2});
        const matDark = new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.8});
        const matWood = new THREE.MeshStandardMaterial({color: 0x553311, roughness: 0.9});
        const matBlue = new THREE.MeshStandardMaterial({color: 0x0088ff, emissive: 0x002244});
        const matGlow = new THREE.MeshBasicMaterial({color: 0x00ff00});

        const hpFill = document.getElementById('hp-bar-fill');
        const hpText = document.getElementById('hp-text');
        const ammoValEl = document.getElementById('ammo-val');
        const ammoResEl = document.getElementById('ammo-reserve');
        const weaponTypeEl = document.getElementById('weapon-type');
        const scoreValEl = document.getElementById('score-val');
        const bossWarning = document.getElementById('boss-warning');
        const interactiveMsg = document.getElementById('interactive-msg');
        const blocker = document.getElementById('blocker');
        const crosshair = document.getElementById('crosshair');
        const bossTracker = document.getElementById('boss-tracker');
        const bossHpFill = document.getElementById('boss-hp-track-fill');
        const bossDistEl = document.getElementById('boss-dist');
        const bossLvlUi = document.getElementById('boss-lvl-ui');

        const SoundGen = {
            ctx: null, masterGain: null, musicNodes: [], creepyInterval: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5; 
                this.masterGain.connect(this.ctx.destination);
                this.startAmbientSystem();
            },
            playTone: function(freq, type, duration, vol, slideTo = null) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            playNoise: function(duration, vol, filterFreq = null) {
                if (!this.ctx) return;
                const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                const src = this.ctx.createBufferSource(); src.buffer = buf;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                if (filterFreq) {
                    const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = filterFreq;
                    src.connect(f); f.connect(gain);
                } else src.connect(gain);
                gain.connect(this.masterGain); src.start();
            },
            startAmbientSystem: function() {
                if (!this.ctx) return;
                this.stopMusic();
                
                // 1. 極其微弱的風聲 (White Noise + Lowpass)，取代原本的持續嗡嗡聲
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const windSrc = this.ctx.createBufferSource();
                windSrc.buffer = buffer;
                windSrc.loop = true;
                const windFilter = this.ctx.createBiquadFilter();
                windFilter.type = 'lowpass';
                windFilter.frequency.value = 100; // 很低頻的風聲
                const windGain = this.ctx.createGain();
                windGain.gain.value = 0.05; // 非常小聲
                windSrc.connect(windFilter);
                windFilter.connect(windGain);
                windGain.connect(this.masterGain);
                windSrc.start();
                this.musicNodes.push(windSrc);

                // 2. 隨機恐懼音效 (間隔拉長，10~20秒一次)
                const playCreepySound = () => {
                    if(this.ctx.state === 'suspended') this.ctx.resume();
                    
                    // 隨機播放一種類型的恐怖音效
                    const r = Math.random();
                    if (r < 0.3) {
                        // 金屬刮擦聲 (高頻)
                        this.playTone(800, 'sawtooth', 0.5, 0.05, 400);
                        setTimeout(() => this.playTone(400, 'sawtooth', 1.0, 0.05, 100), 200);
                    } else if (r < 0.6) {
                        // 遠處低鳴 (低頻)
                        this.playTone(80, 'sine', 3.0, 0.2, 40);
                    } else {
                        // 詭異信號 (不和諧音)
                        this.playTone(440, 'triangle', 0.2, 0.05);
                        setTimeout(() => this.playTone(455, 'triangle', 0.4, 0.05), 200);
                    }

                    // 設置下一次播放的時間 (10秒 ~ 20秒後)
                    const nextTime = 10000 + Math.random() * 10000;
                    this.creepyInterval = setTimeout(playCreepySound, nextTime);
                };
                
                // 啟動循環
                this.creepyInterval = setTimeout(playCreepySound, 5000);
            },
            stopMusic: function() {
                this.musicNodes.forEach(n => { try{n.stop();n.disconnect();}catch(e){} });
                this.musicNodes = [];
                if(this.creepyInterval) clearTimeout(this.creepyInterval);
            },
            shoot: function(isSuper) {
                if (audioSystem && audioSystem.enabled) {
                    if (isSuper) {
                        audioSystem.playSound('shoot2', 0.8);
                    } else {
                        audioSystem.playSound('shoot', 0.8);
                    }
                } else {
                    if(isSuper) {
                        this.playTone(600, 'sawtooth', 0.1, 0.15, 300);
                        this.playNoise(0.05, 0.2);
                    } else {
                        this.playTone(150, 'square', 0.2, 0.3, 50);
                        this.playNoise(0.1, 0.4);
                    }
                }
            },
            empty: function() {
                if (audioSystem && audioSystem.enabled) {
                    audioSystem.playSound('error', 0.6);
                } else {
                    this.playTone(800, 'square', 0.05, 0.1);
                }
            },
            reload: function() {
                if (audioSystem && audioSystem.enabled) {
                    audioSystem.playSound('reload', 0.7);
                } else {
                    setTimeout(()=>this.playTone(600,'square',0.1,0.1),0);
                    setTimeout(()=>this.playTone(500,'sine',0.2,0.1),1000);
                }
            },
            pickup: function() {
                if (audioSystem && audioSystem.enabled) {
                    audioSystem.playSound('pickup', 0.8);
                } else {
                    this.playTone(400, 'sine', 0.1, 0.2);
                    setTimeout(()=>this.playTone(600,'sine',0.2,0.2), 100);
                }
            },
            footstep: function() {
                if (audioSystem && audioSystem.enabled) {
                    audioSystem.playSound('step', 0.3);
                } else {
                    this.playNoise(0.05, 0.1, 200);
                }
            },
            bossSpawn: function() {
                if (audioSystem && audioSystem.enabled) {
                    audioSystem.playSound('boss', 1.0);
                } else {
                    this.playTone(50, 'sawtooth', 3, 0.8, 20);
                    this.playNoise(2, 0.5);
                }
            }
        };

        function generateTexture(type) {
            const s = 512; const c = document.createElement('canvas'); c.width = s; c.height = s; const ctx = c.getContext('2d');
            if (type === 'grass') { ctx.fillStyle = '#051105'; ctx.fillRect(0,0,s,s); }
            if (type === 'stone') { ctx.fillStyle = '#222'; ctx.fillRect(0,0,s,s); }
            if (type === 'wood') { ctx.fillStyle = '#110500'; ctx.fillRect(0,0,s,s); }
            if (type === 'ammo') ctx.fillStyle = '#004400';
            if (type === 'gold') ctx.fillStyle = '#665500';
            
            for(let i=0; i<4000; i++) {
                const x = Math.random()*s, y = Math.random()*s, w = Math.random()*3+1;
                if(type === 'grass') { ctx.fillStyle = Math.random()<0.5?'#0a220a':'#0f2f0f'; ctx.fillRect(x,y,w,w); }
                else if(type === 'stone') { ctx.fillStyle = Math.random()<0.5?'#111':'#333'; ctx.fillRect(x,y,w*2,w*2); }
                else if(type === 'ammo') { ctx.fillStyle = '#0f0'; if(i<50) ctx.fillRect(50, i*10, 400, 5); }
                else if(type === 'gold') { ctx.fillStyle = '#fd0'; ctx.fillRect(x,y,2,2); }
            }
            const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; return t;
        }

        // --- 槍械模型生成器 ---

        function createWingmanModel() {
            const g = new THREE.Group();
            const topBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.8), matSilver);
            topBarrel.position.set(0, 0.2, -0.6); g.add(topBarrel);
            const botBarrel = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.15, 0.7), matWhite);
            botBarrel.position.set(0, 0.05, -0.6); g.add(botBarrel);
            const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.3, 8), matDark);
            cylinder.rotation.z = Math.PI/2; cylinder.position.set(0, 0.2, -0.1); g.add(cylinder);
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.4, 0.15), matWood);
            grip.rotation.x = -0.3; grip.position.set(0, -0.1, 0.2); g.add(grip);
            const sight = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.05, 0.1), matDark);
            sight.position.set(0, 0.32, 0.1); g.add(sight);
            const glow = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.05, 0.4), matGlow);
            glow.position.set(0.08, 0.2, -0.6); glow.name = 'glowBar'; g.add(glow);
            g.position.set(0.5, -0.5, -0.8);
            return g;
        }

        function createR301Model() {
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.15, 1.2), matWhite);
            body.position.set(0, 0.1, -0.6); g.add(body);
            const accent = new THREE.Mesh(new THREE.BoxGeometry(0.13, 0.05, 0.6), matBlue);
            accent.position.set(0, 0.1, -0.4); g.add(accent);
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.8), matDark);
            barrel.rotation.x = Math.PI/2; barrel.position.set(0, 0.1, -1.5); g.add(barrel);
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.12), matDark);
            mag.rotation.x = 0.3; mag.position.set(0, -0.2, -0.5); g.add(mag);
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.35, 0.12), matDark);
            grip.rotation.x = -0.2; grip.position.set(0, -0.2, -0.1); g.add(grip);
            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, 0.5), matDark);
            stock.position.set(0, 0.05, 0.4); g.add(stock);
            const scopeBase = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.05, 0.2), matDark);
            scopeBase.position.set(0, 0.2, -0.3); g.add(scopeBase);
            const scopeGlass = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), matBlue);
            scopeGlass.position.set(0, 0.25, -0.2); g.add(scopeGlass);
            const info = new THREE.Mesh(new THREE.BoxGeometry(0.01, 0.08, 0.2), matGlow);
            info.position.set(0.07, 0.1, -0.8); info.name = 'glowBar'; g.add(info);
            g.position.set(0.5, -0.5, -0.8);
            return g;
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020202);
            scene.fog = new THREE.FogExp2(0x020202, 0.008); 

            const ambient = new THREE.AmbientLight(0x333344, 0.4); scene.add(ambient);
            const moon = new THREE.DirectionalLight(0xaaccff, 0.3); moon.position.set(50,100,50); scene.add(moon);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.y = 6; 

            const pl = new THREE.SpotLight(0xffffff, 80, 200, 0.6, 0.5);
            pl.position.set(0,0,0); pl.target.position.set(0,0,-1);
            camera.add(pl); camera.add(pl.target);

            // 預設武器：Wingman
            playerWeaponGroup = createWingmanModel();
            camera.add(playerWeaponGroup);

            controls = new PointerLockControls(camera, document.body);
            
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => {
                controls.lock();
                // 初始化音效系統
                if (!audioSystem && typeof AudioSystem !== 'undefined') {
                    audioSystem = new AudioSystem();
                    audioSystem.init();
                    audioSystem.preloadSounds();
                }
                if(!SoundGen.ctx) SoundGen.init(); else if(SoundGen.ctx.state === 'suspended') SoundGen.ctx.resume();
            });
            controls.addEventListener('lock', () => { blocker.style.display = 'none'; });
            controls.addEventListener('unlock', () => { if(player.hp>0) blocker.style.display = 'flex'; });

            scene.add(controls.getObject());

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            raycaster = new THREE.Raycaster();

            const gTex = generateTexture('grass'); gTex.repeat.set(50,50);
            floorMaterial = new THREE.MeshStandardMaterial({map: gTex, roughness: 0.9});
            stoneMaterial = new THREE.MeshStandardMaterial({map: generateTexture('stone'), roughness: 0.7});
            woodMaterial = new THREE.MeshStandardMaterial({map: generateTexture('wood'), roughness: 0.9});
            ammoMat = new THREE.MeshStandardMaterial({color: 0x00ff00, map: generateTexture('ammo'), emissive: 0x002200});
            weaponDropMat = new THREE.MeshStandardMaterial({color: 0xffd700, map: generateTexture('gold'), emissive: 0x443300, metalness:1});

            createEnvironment();
            
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            updateUI();
            
            // 初始化音效系統
            initAudioSystem();
            
            // 初始化難度設定
            initDifficultySettings();
            
            // 初始化音效控制
            initAudioControls();
            
            // 添加鍵盤快捷鍵
            document.addEventListener('keydown', (e) => {
                if (e.code === 'F1') {
                    e.preventDefault();
                    const settings = document.getElementById('difficulty-settings');
                    settings.style.display = settings.style.display === 'block' ? 'none' : 'block';
                }
                if (e.code === 'F2') {
                    e.preventDefault();
                    const audio = document.getElementById('audio-controls');
                    audio.style.display = audio.style.display === 'block' ? 'none' : 'block';
                }
            });
        }
        
        function initAudioSystem() {
            if (typeof AudioSystem !== 'undefined') {
                audioSystem = new AudioSystem();
                audioSystem.init();
                audioSystem.preloadSounds();
                console.log('共用音效系統已載入');
            } else {
                console.warn('共用音效系統未找到，使用內建音效');
            }
        }
        
        function initDifficultySettings() {
            const options = document.querySelectorAll('.difficulty-option');
            options.forEach(option => {
                option.addEventListener('click', () => {
                    // 移除所有選中狀態
                    options.forEach(opt => opt.classList.remove('selected'));
                    // 添加選中狀態
                    option.classList.add('selected');
                    // 更新玩家難度
                    const level = parseInt(option.getAttribute('data-level'));
                    player.difficultyLevel = level;
                    console.log(`難度設定為: ${difficultySettings[level].name}`);
                });
            });
        }
        
        function initAudioControls() {
            const masterSlider = document.getElementById('master-volume');
            const sfxSlider = document.getElementById('sfx-volume');
            const musicSlider = document.getElementById('music-volume');
            const toggleBtn = document.getElementById('audio-toggle');
            
            if (audioSystem) {
                // 載入保存的設定
                audioSystem.loadSettings();
                
                // 設定滑桿初始值
                masterSlider.value = audioSystem.masterVolume * 100;
                sfxSlider.value = audioSystem.sfxVolume * 100;
                musicSlider.value = audioSystem.musicVolume * 100;
                
                // 更新按鈕文字
                toggleBtn.textContent = audioSystem.enabled ? '音效: 開啟' : '音效: 關閉';
                toggleBtn.style.background = audioSystem.enabled ? '#00aa00' : '#aa0000';
                
                // 綁定事件
                masterSlider.addEventListener('input', (e) => {
                    audioSystem.setMasterVolume(e.target.value / 100);
                    audioSystem.saveSettings();
                });
                
                sfxSlider.addEventListener('input', (e) => {
                    audioSystem.setSfxVolume(e.target.value / 100);
                    audioSystem.saveSettings();
                });
                
                musicSlider.addEventListener('input', (e) => {
                    audioSystem.setMusicVolume(e.target.value / 100);
                    audioSystem.saveSettings();
                });
                
                toggleBtn.addEventListener('click', () => {
                    audioSystem.toggleEnabled();
                    toggleBtn.textContent = audioSystem.enabled ? '音效: 開啟' : '音效: 關閉';
                    toggleBtn.style.background = audioSystem.enabled ? '#00aa00' : '#aa0000';
                    audioSystem.saveSettings();
                });
            }
        }

        function updateUI() {
            hpText.innerText = Math.floor(player.hp);
            hpFill.style.width = Math.max(0, player.hp) + '%';
            ammoValEl.innerText = player.ammo;
            ammoResEl.innerText = player.reserveAmmo;
            scoreValEl.innerText = player.score;
            ammoValEl.style.color = player.ammo <= 2 ? 'red' : '#ffff00';
            
            if (player.ammo === 0 && player.reserveAmmo > 0) {
                interactiveMsg.style.display = 'block';
                interactiveMsg.innerText = "警告：彈藥耗盡 - 按 [R] 裝填";
                interactiveMsg.style.color = "red";
                interactiveMsg.style.borderColor = "red";
            } else if (!focusItem) {
                interactiveMsg.style.display = 'none';
            }
        }

        function checkBossSpawn() {
            if (player.score >= bossState.nextSpawnScore && !bossState.active) {
                spawnBoss();
                bossState.nextSpawnScore += 400; 
            }
        }

        function reloadWeapon() {
            if (player.isReloading || player.ammo === player.maxMag || player.reserveAmmo === 0) return;
            player.isReloading = true;
            crosshair.classList.add('reloading');
            SoundGen.reload();
            
            const startY = -0.5; 
            let p = 0;
            const interval = setInterval(() => {
                p += 0.05;
                if(player.isSuperWeapon) {
                    if(p < 0.5) { playerWeaponGroup.position.z += 0.05; playerWeaponGroup.rotation.x += 0.05; }
                    else { playerWeaponGroup.position.z -= 0.05; playerWeaponGroup.rotation.x -= 0.05; }
                } else {
                    if(p < 0.5) { playerWeaponGroup.rotation.z += 0.2; playerWeaponGroup.rotation.x -= 0.1; }
                    else { playerWeaponGroup.rotation.z -= 0.2; playerWeaponGroup.rotation.x += 0.1; }
                }

                if(p >= 1.5) {
                    clearInterval(interval);
                    const needed = player.maxMag - player.ammo;
                    const take = Math.min(needed, player.reserveAmmo);
                    player.ammo += take; player.reserveAmmo -= take;
                    
                    playerWeaponGroup.rotation.set(0,0,0); 
                    playerWeaponGroup.position.set(0.5, -0.5, -0.8);
                    player.isReloading = false;
                    crosshair.classList.remove('reloading');
                    updateUI();
                }
            }, 50);
        }

        function createEnvironment() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000).rotateX(-Math.PI/2), floorMaterial);
            floor.receiveShadow = true; scene.add(floor);
            const tGeo = new THREE.BoxGeometry(4, 7, 1);
            const trGeo = new THREE.ConeGeometry(3, 20, 5);
            for(let i=0; i<250; i++) {
                const x = (Math.random()-0.5)*800, z = (Math.random()-0.5)*800;
                if(Math.abs(x)<50 && Math.abs(z)<50) continue;
                const isTree = Math.random() < 0.2;
                const m = new THREE.Mesh(isTree?trGeo:tGeo, isTree?woodMaterial:stoneMaterial);
                m.position.set(x, isTree?10:3.5, z);
                if(!isTree) m.rotation.y = (Math.random()-0.5);
                scene.add(m);
            }
        }

        function spawnGhost() {
            const max = 10 + Math.floor(player.score/200);
            if (enemyUnits.length > max) return;
            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.ConeGeometry(3, 8, 8, 1, true), 
                new THREE.MeshStandardMaterial({color: 0x88ffff, emissive: 0x004444, transparent: true, opacity: 0.7, side: THREE.DoubleSide}));
            body.position.y = 4; g.add(body);
            const head = new THREE.Mesh(new THREE.SphereGeometry(2), body.material);
            head.position.y = 8; g.add(head);
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xff0000}));
            const le = eye.clone(); le.position.set(-0.8, 8.5, 1.5); g.add(le);
            const re = eye.clone(); re.position.set(0.8, 8.5, 1.5); g.add(re);
            spawnUnit(g, 100 + (player.score/20), 12 + Math.random()*8, 'normal');
        }

        function spawnBoss() {
            bossState.active = true;
            bossState.count++;
            SoundGen.bossSpawn();
            bossWarning.style.display = 'block';
            setTimeout(() => bossWarning.style.display = 'none', 4000);
            const level = bossState.count;
            const multiplier = 1 + (level * 0.5); 
            const g = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x660000, roughness: 0.3, metalness: 0.8, emissive: 0x550000, emissiveIntensity: 0.8 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(5*multiplier, 3*multiplier, 15*multiplier, 6), mat);
            body.position.y = 7.5*multiplier; g.add(body);
            const head = new THREE.Mesh(new THREE.DodecahedronGeometry(4*multiplier), mat);
            head.position.y = 16*multiplier; g.add(head);
            const eyeGeo = new THREE.BoxGeometry(1*multiplier, 0.5*multiplier, 1*multiplier);
            const eyeMat = new THREE.MeshBasicMaterial({color: 0xff0000});
            const le = new THREE.Mesh(eyeGeo, eyeMat); le.position.set(-2*multiplier, 16*multiplier, 3*multiplier);
            const re = new THREE.Mesh(eyeGeo, eyeMat); re.position.set(2*multiplier, 16*multiplier, 3*multiplier);
            g.add(le); g.add(re);
            const halo = new THREE.Mesh(new THREE.TorusGeometry(6*multiplier, 0.5, 16, 50), new THREE.MeshBasicMaterial({color:0xff0000}));
            halo.rotation.x = Math.PI/2; halo.position.y = 22*multiplier; halo.name = "halo"; g.add(halo);
            const light = new THREE.PointLight(0xff0000, 5, 40*multiplier);
            light.position.y = 10; g.add(light);
            const hp = 800 * multiplier;
            const unit = spawnUnit(g, hp, (18 + (level * 2)), 'boss');
            unit.maxHp = hp; bossState.unit = unit;
            bossLvlUi.innerText = level; bossTracker.style.display = 'block';
        }

        function spawnUnit(group, hp, speed, type) {
            const angle = Math.random() * Math.PI * 2;
            const rad = 100 + Math.random() * 100;
            group.position.set(controls.getObject().position.x + Math.cos(angle)*rad, 0, controls.getObject().position.z + Math.sin(angle)*rad);
            scene.add(group);
            const unit = { group: group, hp: hp, speed: speed, type: type, floatOffset: Math.random()*100 };
            enemyUnits.push(unit);
            return unit;
        }

        function spawnDrop(pos) {
            // --- 平衡調整：掉落物邏輯 ---
            // 只有 15% 機率是武器 (變得很稀有)，85% 是彈藥
            const isWeapon = Math.random() < 0.4; 
            const mesh = new THREE.Mesh(
                isWeapon ? new THREE.BoxGeometry(1,1,3) : new THREE.BoxGeometry(2,2,2),
                isWeapon ? weaponDropMat : ammoMat
            );
            mesh.userData = { 
                type: isWeapon?'weapon':'ammo', 
                label: isWeapon?'[R-301 卡賓槍]':'彈藥箱',
                rotateSpeed: isWeapon?3:1 
            };
            mesh.position.copy(pos); mesh.position.y = 3;
            
            // 光柱 (武器是金光，彈藥是綠光)
            const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 50, 8), 
                new THREE.MeshBasicMaterial({color: isWeapon?0xffff00:0x00ff00, transparent:true, opacity:0.3}));
            beam.position.y = 25;
            mesh.add(beam);
            
            scene.add(mesh); dropItems.push(mesh);
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if(canJump) velocity.y += 250; canJump = false; break;
                case 'KeyR': reloadWeapon(); break;
                case 'KeyE': tryPickup(); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        function onMouseDown() {
            if(!controls.isLocked || player.hp<=0 || player.isReloading) return;
            if(player.ammo <= 0) { SoundGen.empty(); reloadWeapon(); return; }
            if(performance.now() - lastShootTime < (player.isSuperWeapon ? 100 : 400)) return; 
            lastShootTime = performance.now();

            SoundGen.shoot(player.isSuperWeapon);
            player.ammo--; updateUI();
            
            const recoilZ = player.isSuperWeapon ? 0.1 : 0.3;
            playerWeaponGroup.position.z += recoilZ; 
            playerWeaponGroup.rotation.x += (player.isSuperWeapon ? 0.05 : 0.15);
            setTimeout(()=> {
                playerWeaponGroup.position.z -= recoilZ;
                playerWeaponGroup.rotation.x -= (player.isSuperWeapon ? 0.05 : 0.15);
            }, 80);

            const flash = new THREE.PointLight(player.isSuperWeapon?0x0088ff:0xffaa00, 5, 20);
            flash.position.set(0.5, -0.4, -2); camera.add(flash); setTimeout(()=>camera.remove(flash), 50);

            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const targets = [];
            enemyUnits.forEach(u => u.group.children.forEach(c => targets.push(c)));
            const intersects = raycaster.intersectObjects(targets);
            if(intersects.length > 0) {
                const hitObj = intersects[0].object;
                const parent = hitObj.parent;
                const idx = enemyUnits.findIndex(u => u.group === parent);
                if(idx > -1) hitEnemy(idx);
            }
        }

        function hitEnemy(idx) {
            const unit = enemyUnits[idx];
            unit.hp -= player.damage;
            unit.group.children.forEach(m => {
                if(m.material && m.material.emissive) {
                    const old = m.material.emissive.getHex();
                    m.material.emissive.setHex(0xffffff);
                    setTimeout(()=> m.material.emissive.setHex(old), 50);
                }
            });
            if(unit.hp <= 0) {
                if (unit.type === 'boss') {
                    bossState.active = false; bossState.unit = null; bossTracker.style.display = 'none';
                    player.score += 1000;
                    spawnDrop(unit.group.position); spawnDrop(unit.group.position); 
                } else {
                    player.score += 100;
                    // --- 平衡調整：掉落率 ---
                    // 30% 機率掉落東西 (之前是 50%)
                    if(Math.random() < 0.5) spawnDrop(unit.group.position); 
                }
                scene.remove(unit.group); enemyUnits.splice(idx, 1);
                checkBossSpawn(); updateUI();
            }
        }

        function tryPickup() {
            if(focusItem) {
                const idx = dropItems.indexOf(focusItem);
                if(idx > -1) {
                    SoundGen.pickup();
                    const item = dropItems[idx];
                    if(item.userData.type === 'ammo') {
                        player.reserveAmmo += player.isSuperWeapon ? 60 : 12;
                    } else {
                        player.isSuperWeapon = true;
                        player.damage = 25; 
                        player.maxMag = 28;
                        player.ammo = 28;
                        player.reserveAmmo = 120;
                        weaponTypeEl.innerText = "R-301 CARBINE";
                        weaponTypeEl.style.color = "#0088ff";
                        camera.remove(playerWeaponGroup);
                        playerWeaponGroup = createR301Model();
                        camera.add(playerWeaponGroup);
                    }
                    scene.remove(item); dropItems.splice(idx, 1);
                    focusItem = null; updateUI();
                }
            }
        }

        function updateBossUI() {
            if (!bossState.active || !bossState.unit) { bossTracker.style.display = 'none'; return; }
            const boss = bossState.unit;
            const hpPercent = Math.max(0, (boss.hp / boss.maxHp) * 100);
            bossHpFill.style.width = hpPercent + '%';
            const headPos = boss.group.position.clone();
            headPos.y += (boss.type === 'boss' ? 25 : 10); 
            headPos.project(camera);
            if (headPos.z < 1) {
                const x = (headPos.x * .5 + .5) * window.innerWidth;
                const y = (-(headPos.y * .5) + .5) * window.innerHeight;
                bossTracker.style.display = 'block';
                bossTracker.style.transform = `translate(${x - 110}px, ${y - 120}px)`;
                const dist = Math.floor(boss.group.position.distanceTo(camera.position));
                bossDistEl.innerText = `DIST: ${dist}m`;
                if (hpPercent < 30) { bossHpFill.style.backgroundColor = '#ffcc00'; } 
                else { bossHpFill.style.backgroundColor = '#ff0000'; }
            } else { bossTracker.style.display = 'none'; }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = performance.now();
            
            if(SoundGen.ctx && SoundGen.ctx.state === 'suspended') {
                SoundGen.ctx.resume();
            }

            if (controls.isLocked && player.hp > 0) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta;
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();
                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);
                
                if (controls.getObject().position.y < 6) {
                    velocity.y = 0; controls.getObject().position.y = 6; canJump = true;
                    if((moveForward||moveBackward||moveLeft||moveRight) && time-lastStepTime > 400) {
                        SoundGen.footstep(); lastStepTime = time;
                    }
                }

                const pPos = controls.getObject().position;
                enemyUnits.forEach(u => {
                    u.group.lookAt(pPos.x, u.group.position.y, pPos.z);
                    const dist = u.group.position.distanceTo(pPos);
                    if (u.type === 'normal') { u.group.position.y = Math.sin(time * 0.003 + u.floatOffset) * 0.5; }
                    if (dist > (u.type==='boss'?15:8)) {
                        const dir = new THREE.Vector3().subVectors(pPos, u.group.position).normalize();
                        u.group.position.add(dir.multiplyScalar(u.speed * delta));
                    } else {
                        player.hp -= delta * (u.type==='boss'?50:20);
                        updateUI();
                        if(player.hp <= 0) {
                            controls.unlock();
                            blocker.style.display = 'flex';
                            SoundGen.stopMusic();
                            document.getElementById('start-btn').innerHTML = "<h1 style='color:red'>MISSION FAILED</h1><p>重新整理頁面再來一次</p>";
                        }
                    }
                    if(u.type === 'boss') {
                        const halo = u.group.getObjectByName('halo');
                        if(halo) { halo.rotation.z += delta * 2; halo.rotation.x = Math.PI/2 + Math.sin(time*0.002)*0.5; }
                    }
                });

                let closest = 10, target = null;
                dropItems.forEach(i => {
                    i.rotation.y += delta * i.userData.rotateSpeed;
                    i.position.y = 3 + Math.sin(time*0.003)*0.5;
                    const d = pPos.distanceTo(i.position);
                    if(d < 10 && d < closest) { closest = d; target = i; }
                });
                focusItem = target;
                if(focusItem) {
                    interactiveMsg.style.display = 'block';
                    interactiveMsg.style.color = focusItem.userData.type === 'weapon' ? '#ffcc00' : '#00ffff'; 
                    interactiveMsg.style.borderColor = focusItem.userData.type === 'weapon' ? '#ffcc00' : 'cyan';
                    interactiveMsg.innerText = `[E] 拾取 ${focusItem.userData.label}`;
                } else if (player.ammo > 0) { interactiveMsg.style.display = 'none'; }

                if (!bossState.active) {
                    checkBossSpawn(); 
                    if (Math.random() < 0.02 && enemyUnits.length < 10) spawnGhost();
                } else {
                    if (Math.random() < 0.005 && enemyUnits.length < 5) spawnGhost();
                }
                updateBossUI();
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>