<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Graveyard Shooter - Textured & Stable</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background-color: #111; }
        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: #ffffff; z-index: 999;
        }
        #instructions { font-size: 30px; cursor: pointer; text-align: center; text-shadow: 2px 2px 4px #000; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #00ff00;
            font-size: 24px; font-weight: bold; pointer-events: none;
            text-shadow: 2px 2px 4px black;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 24px; height: 24px;
            background: transparent;
            border: 2px solid rgba(0, 255, 0, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            width: 4px; height: 4px; background: #00ff00;
            transform: translate(-50%, -50%); border-radius: 50%;
        }
        #loading { position: absolute; bottom: 20px; left: 20px; color: yellow; font-weight: bold; background: rgba(0,0,0,0.5); padding: 5px;}
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
    <div id="ui">
        KILLS: <span id="score">0</span> | HEALTH: <span id="health">100</span>%
    </div>
    <div id="crosshair"></div>
    <div id="loading">正在初始化...</div>
    
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:50px; letter-spacing: 5px;">墳場獵人：重製版</p>
            <p>點擊畫面開始</p>
            <p>W, A, S, D 移動 | 空白鍵 跳躍 | 滑鼠左鍵 射擊</p>
            <p style="font-size: 16px; color: #aaa;">(如果看不見精細模型，將使用替代紅體)</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let camera, scene, renderer, controls;
        let raycaster;
        const clock = new THREE.Clock();
        
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        
        let enemyUnits = []; 
        let score = 0;
        let health = 100;
        let lastShootTime = 0;
        let playerWeapon;
        
        // 模型相關變數
        let ghostModelTemplate = null;
        let ghostAnimations = null;
        let enemyModelLoaded = false; // 標記外部模型是否成功加載
        
        // 紋理資源
        let groundTexture, stoneTexture;

        const scoreEl = document.getElementById('score');
        const healthEl = document.getElementById('health');
        const blocker = document.getElementById('blocker');
        const loadingEl = document.getElementById('loading');

        // 資源 URLs (使用較穩定的 CDN)
        const WEAPON_URL = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/BoomBox/glTF-Binary/BoomBox.glb'; 
        const ENEMY_URL = 'https://threejs.org/examples/models/gltf/Soldier.glb'; 
        // 紋理 URLs
        const GROUND_TEX_URL = 'https://threejs.org/examples/textures/terrain/grasslight-big.jpg';
        const STONE_TEX_URL = 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/paving/PavingStones092_1K_Color.jpg';


        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111122); // 深藍夜色
            scene.fog = new THREE.FogExp2(0x111122, 0.008); 

            // --- 燈光系統 ---
            const ambientLight = new THREE.AmbientLight(0x9999ff, 0.6); // 偏藍環境光
            scene.add(ambientLight);
            
            const moonLight = new THREE.DirectionalLight(0xffffff, 1.2); // 月光
            moonLight.position.set(50, 100, 50);
            moonLight.castShadow = true;
            moonLight.shadow.mapSize.width = 2048;
            moonLight.shadow.mapSize.height = 2048;
            moonLight.shadow.bias = -0.0001;
            scene.add(moonLight);

            // 玩家手電筒
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 12;
            const flashlight = new THREE.SpotLight(0xffddaa, 80, 250, 0.5, 0.8, 1); // 暖色手電筒
            flashlight.position.set(0, 0, 0);
            flashlight.target.position.set(0, 0, -1);
            camera.add(flashlight);
            camera.add(flashlight.target);

            controls = new PointerLockControls(camera, document.body);

            const instructions = document.getElementById('instructions');
            instructions.addEventListener('click', function () { controls.lock(); });
            controls.addEventListener('lock', function () { instructions.style.display = 'none'; blocker.style.display = 'none'; });
            controls.addEventListener('unlock', function () { blocker.style.display = 'flex'; instructions.style.display = ''; });
            scene.add(controls.getObject());

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);

            // --- 資源加載管理器 ---
            const manager = new THREE.LoadingManager();
            manager.onProgress = (url, itemsLoaded, itemsTotal) => {
                loadingEl.innerText = `正在加載資源: ${Math.round(itemsLoaded / itemsTotal * 100)}%`;
            };
            manager.onLoad = () => {
                loadingEl.style.display = 'none';
                createGraveyardEnvironment(); // 資源加載完畢後再創建環境
                // 初始生成幾個敵人
                for(let i=0; i<5; i++) spawnEnemy();
            };
            manager.onError = (url) => {
                 loadingEl.innerText = '部分資源加載失敗，將使用替代方案。';
                 console.warn('Loading error on: ' + url);
            };

            const texLoader = new THREE.TextureLoader(manager);
            const gltfLoader = new GLTFLoader(manager);

            // 1. 加載紋理
            groundTexture = texLoader.load(GROUND_TEX_URL);
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(50, 50); // 地面紋理重複
            
            stoneTexture = texLoader.load(STONE_TEX_URL);
            stoneTexture.wrapS = stoneTexture.wrapT = THREE.RepeatWrapping;

            // 2. 加載模型
            gltfLoader.load(WEAPON_URL, (gltf) => {
                playerWeapon = gltf.scene;
                playerWeapon.scale.set(100, 100, 100); 
                playerWeapon.position.set(1.5, -1.5, -2.5);
                playerWeapon.rotation.y = Math.PI;
                camera.add(playerWeapon);
            }, undefined, (e) => { console.warn("Weapon failed to load"); });

            gltfLoader.load(ENEMY_URL, (gltf) => {
                // 成功加載外部敵人模型
                const model = gltf.scene;
                ghostAnimations = gltf.animations;
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x88ffff, 
                            emissive: 0x004444,
                            roughness: 0.1,
                            metalness: 0.8
                        });
                        child.castShadow = true;
                    }
                });
                model.scale.set(7, 7, 7);
                ghostModelTemplate = model;
                enemyModelLoaded = true; // 標記成功
            }, undefined, (e) => { 
                console.warn("Enemy model failed to load, switching to fallback.");
                enemyModelLoaded = false; // 標記失敗，將使用替代品
            });

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.body.appendChild(renderer.domElement);
        }

        function createGraveyardEnvironment() {
            // 地面 (應用紋理)
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            floorGeometry.rotateX(- Math.PI / 2);
            const positionAttribute = floorGeometry.attributes.position;
            for ( let i = 0; i < positionAttribute.count; i ++ ) {
                 if (positionAttribute.getY(i) === 0) positionAttribute.setY( i, Math.random() * 3); // 增加起伏
            }
            floorGeometry.computeVertexNormals();

            const floorMaterial = new THREE.MeshStandardMaterial({ 
                map: groundTexture, // 應用草地紋理
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.receiveShadow = true;
            scene.add(floor);

            // 墓碑 (應用石材紋理)
            const tombGeo = new THREE.BoxGeometry(5, 10, 3);
            const tombMat = new THREE.MeshStandardMaterial({ 
                map: stoneTexture, // 應用石頭紋理
                roughness: 0.8 
            });
            
            // 枯樹 (保持深色粗糙材質)
            const treeGeo = new THREE.ConeGeometry(4, 30, 6);
            const treeMat = new THREE.MeshStandardMaterial({ color: 0x221100, roughness: 1 }); 

            for (let i = 0; i < 120; i++) {
                const tomb = new THREE.Mesh(tombGeo, tombMat);
                tomb.position.x = (Math.random() - 0.5) * 800;
                tomb.position.z = (Math.random() - 0.5) * 800;
                tomb.position.y = 4.5;
                tomb.rotation.y = Math.random() * 0.5;
                tomb.rotation.x = (Math.random() - 0.5) * 0.3;
                tomb.castShadow = true;
                tomb.receiveShadow = true;
                scene.add(tomb);

                if (i % 4 === 0) {
                     const tree = new THREE.Mesh(treeGeo, treeMat);
                     tree.position.x = (Math.random() - 0.5) * 800;
                     tree.position.z = (Math.random() - 0.5) * 800;
                     tree.position.y = 15;
                     tree.rotation.y = Math.random() * Math.PI;
                     tree.castShadow = true;
                     scene.add(tree);
                }
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if (canJump === true) velocity.y += 250; canJump = false; break;
            }
        }
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseDown(event) {
            if (!controls.isLocked || health <= 0) return;
            const now = performance.now();
            if (now - lastShootTime < 200) return; 
            lastShootTime = now;

            const flash = new THREE.PointLight(0xffffaa, 8, 30);
            flash.position.set(1.5, -1, -3);
            camera.add(flash);
            setTimeout(() => camera.remove(flash), 40);
            
            if(playerWeapon) {
                playerWeapon.position.z += 0.25;
                setTimeout(() => { playerWeapon.position.z -= 0.25; }, 80);
            }

            const shootRaycaster = new THREE.Raycaster();
            shootRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

            const enemyMeshes = enemyUnits.map(u => u.mesh);
            const intersects = shootRaycaster.intersectObjects(enemyMeshes, true);

            if (intersects.length > 0) {
                let hitObject = intersects[0].object;
                // 如果是複雜模型，向上尋找父級；如果是簡單替代模型，它自己就是主體
                while(hitObject.parent && hitObject.parent.type !== 'Scene' && !enemyMeshes.includes(hitObject)) {
                    hitObject = hitObject.parent;
                }
                
                const hitUnitIndex = enemyUnits.findIndex(u => u.mesh === hitObject);
                if (hitUnitIndex > -1) {
                    destroyEnemy(hitUnitIndex);
                }
            }
        }

        function destroyEnemy(index) {
            const unit = enemyUnits[index];
            scene.remove(unit.mesh);
            if(unit.mixer) unit.mixer.stopAllAction(); // 只有複雜模型有 mixer
            enemyUnits.splice(index, 1);
            score++;
            scoreEl.innerText = score;
            
            // 爆炸特效
            const geometry = new THREE.DodecahedronGeometry(4, 0);
            const material = new THREE.MeshBasicMaterial({ color: 0xff5500, wireframe: true });
            const explosion = new THREE.Mesh(geometry, material);
            explosion.position.copy(unit.mesh.position);
            scene.add(explosion);
            let scale = 1.0;
            const animExp = () => {
                scale += 0.3;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.08;
                explosion.rotation.y += 0.1;
                if (scale < 6) requestAnimationFrame(animExp);
                else scene.remove(explosion);
            };
            animExp();
        }

        // --- 核心修改：安全的敵人生成 ---
        function spawnEnemy() {
            if (enemyUnits.length > 20) return; 

            let enemyMesh, mixer = null;

            // 判斷：如果外部模型加載成功，使用它；否則使用替代品
            if (enemyModelLoaded && ghostModelTemplate) {
                // --- 方案 A: 使用精細 3D 模型 ---
                enemyMesh = ghostModelTemplate.clone();
                mixer = new THREE.AnimationMixer(enemyMesh);
                const clip = ghostAnimations[1] || ghostAnimations[0]; 
                if (clip) {
                    const action = mixer.clipAction(clip);
                    action.play();
                }
                // 調整高度以適應地面
                enemyMesh.position.y = 0;
            } else {
                // --- 方案 B: 使用替代品 (紅色發光膠囊) ---
                // 確保即使網絡不好，玩家也有東西可以打
                const geo = new THREE.CapsuleGeometry(4, 10, 8);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000, 
                    emissive: 0xaa0000, // 強烈自發光
                    roughness: 0.4,
                    metalness: 0.6
                });
                enemyMesh = new THREE.Mesh(geo, mat);
                enemyMesh.castShadow = true;
                // 替代品懸浮在空中
                enemyMesh.position.y = 10;
            }

            // 共同的生成位置邏輯
            const angle = Math.random() * Math.PI * 2;
            const radius = 150 + Math.random() * 250;
            enemyMesh.position.x = controls.getObject().position.x + Math.cos(angle) * radius;
            enemyMesh.position.z = controls.getObject().position.z + Math.sin(angle) * radius;

            scene.add(enemyMesh);
            // 儲存資料單元 (替代品沒有 mixer)
            enemyUnits.push({ mesh: enemyMesh, mixer: mixer, speed: 25 + Math.random() * 20 });
        }

        function updateGameState(delta) {
            const playerPos = controls.getObject().position;
            
            enemyUnits.forEach((unit, index) => {
                // 如果有動畫混合器就更新 (替代品沒有)
                if (unit.mixer) unit.mixer.update(delta);
                
                const lookAtPos = new THREE.Vector3(playerPos.x, unit.mesh.position.y, playerPos.z);
                unit.mesh.lookAt(lookAtPos); 

                const direction = new THREE.Vector3().subVectors(playerPos, unit.mesh.position);
                const distance = direction.length();

                if (distance > 18) {
                    direction.normalize();
                    unit.mesh.position.add(direction.multiplyScalar(unit.speed * delta));
                } else {
                    health -= delta * 15; 
                    healthEl.innerText = Math.floor(Math.max(0, health));
                    // 受傷紅屏效果 (簡單模擬)
                    blocker.style.backgroundColor = `rgba(255,0,0,${(100-health)/200})`;
                    if (health <= 0) {
                        controls.unlock();
                        blocker.style.backgroundColor = 'rgba(200,0,0,0.8)';
                        instructions.innerHTML = "<p>你死了。</p><p>點擊刷新重試</p>";
                        instructions.onclick = () => location.reload();
                    }
                }

                // 替代品的額外漂浮動畫
                if (!unit.mixer) {
                     unit.mesh.position.y = 10 + Math.sin(clock.elapsedTime * 3 + index) * 2;
                }
            });
            
            // 持續生成，保持壓力
            if (enemyUnits.length < 15 && Math.random() < 0.05 && health > 0) spawnEnemy();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); 

            if (controls.isLocked === true && health > 0) {
                velocity.x -= velocity.x * 8.0 * delta;
                velocity.z -= velocity.z * 8.0 * delta;
                velocity.y -= 9.8 * 80.0 * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 450.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 450.0 * delta;

                controls.moveRight(- velocity.x * delta);
                controls.moveForward(- velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                if (controls.getObject().position.y < 12) {
                    velocity.y = 0;
                    controls.getObject().position.y = 12;
                    canJump = true;
                }
                
                updateGameState(delta);
            } else if (health > 0) {
                // 暫停時重置紅屏
                blocker.style.backgroundColor = 'rgba(0,0,0,0.6)';
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>