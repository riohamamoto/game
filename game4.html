<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Graveyard Shooter - Fixed</title>
    <style>
        /* --- 基礎設定 --- */
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; font-family: 'Segoe UI', 'Courier New', monospace; }
        
        /* --- 全螢幕特效 (頭盔面罩感) --- */
        #screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,20,0,0.6) 90%); /* 暗角 */
            box-shadow: inset 0 0 100px rgba(0,0,0,0.9);
            z-index: 10;
        }
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            z-index: 11; opacity: 0.6;
        }

        /* --- 準心 --- */
        #crosshair-wrapper {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: none; z-index: 20;
            display: flex; align-items: center; justify-content: center;
        }
        #crosshair {
            width: 40px; height: 40px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            position: relative;
            transition: all 0.1s;
            box-shadow: 0 0 10px cyan;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: #fff; border-radius: 50%;
        }
        #crosshair.reloading {
            border-color: #ffaa00; border-style: dashed; animation: spin 1s infinite linear;
            width: 60px; height: 60px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* --- 複雜 UI 容器 --- */
        #hud {
            position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 15;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* 通用 HUD 模塊樣式 */
        .hud-panel {
            background: rgba(0, 20, 40, 0.7);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-left: 5px solid cyan;
            padding: 15px;
            backdrop-filter: blur(4px);
            clip-path: polygon(0 0, 100% 0, 100% 85%, 90% 100%, 0 100%);
            color: #fff;
            text-shadow: 0 0 5px cyan;
            transition: all 0.2s;
        }

        /* 左下：生命值 */
        .hud-bottom-left { position: absolute; bottom: 30px; left: 30px; width: 300px; }
        .hp-segment {
            display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 5px;
        }
        .hud-label { font-size: 12px; color: #aaa; letter-spacing: 2px; }
        .hud-value-big { font-size: 36px; font-weight: bold; line-height: 1; }
        
        #hp-bar-container {
            width: 100%; height: 15px; background: #001122;
            border: 1px solid #004455; transform: skewX(-20deg); overflow: hidden;
        }
        #hp-bar-fill {
            width: 100%; height: 100%; background: linear-gradient(90deg, #ff0000, #ffff00);
            box-shadow: 0 0 10px #ff0000;
        }

        /* 右下：彈藥 */
        .hud-bottom-right { position: absolute; bottom: 30px; right: 30px; text-align: right; border-left: none; border-right: 5px solid yellow; clip-path: polygon(10% 0, 100% 0, 100% 100%, 0 100%, 0 15%); }
        #ammo-val { font-size: 60px; color: #ffff00; text-shadow: 0 0 15px #ffaa00; }
        #weapon-type { font-size: 14px; color: #ccc; text-transform: uppercase; border-top: 1px solid #555; padding-top: 5px; margin-top: 5px; }

        /* 頂部：分數與波次 */
        .hud-top-center { 
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 20px; 
        }
        .score-box {
            background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2);
            padding: 5px 20px; border-radius: 20px; text-align: center;
        }
        #boss-warning {
            color: #ff0000; font-weight: bold; font-size: 18px; display: none;
            animation: pulseWarning 0.5s infinite alternate;
        }
        @keyframes pulseWarning { from { opacity: 0.5; text-shadow: 0 0 5px red; } to { opacity: 1; text-shadow: 0 0 20px red; } }

        /* --- BOSS 懸浮 UI (複雜版) --- */
        #boss-tracker {
            position: absolute; top: 0; left: 0;
            width: 220px; pointer-events: none; display: none; z-index: 25;
        }
        .boss-hud-inner {
            border: 2px solid #ff0000; background: rgba(30, 0, 0, 0.8);
            padding: 10px; position: relative;
        }
        /* 裝飾線條 */
        .boss-hud-inner::before {
            content: ''; position: absolute; top: -5px; left: -5px; width: 10px; height: 10px;
            border-top: 2px solid red; border-left: 2px solid red;
        }
        .boss-hud-inner::after {
            content: ''; position: absolute; bottom: -5px; right: -5px; width: 10px; height: 10px;
            border-bottom: 2px solid red; border-right: 2px solid red;
        }
        
        .boss-header { display: flex; justify-content: space-between; color: #ff5555; font-size: 12px; font-weight: bold; margin-bottom: 5px;}
        .boss-name { font-size: 16px; color: #ff0000; text-shadow: 0 0 10px red; text-transform: uppercase; font-weight: 900; letter-spacing: 1px;}
        
        #boss-hp-track-bg { width: 100%; height: 8px; background: #330000; margin-top: 5px; }
        #boss-hp-track-fill { width: 100%; height: 100%; background: #ff0000; transition: width 0.1s linear; }
        
        #boss-dist { font-size: 10px; color: #fff; text-align: right; margin-top: 2px; }
        
        /* 連接線 */
        #boss-line {
            position: absolute; top: 100%; left: 50%; width: 2px; height: 30px; 
            background: linear-gradient(to bottom, red, transparent);
            transform: translateX(-50%);
        }

        /* 互動提示 */
        #interactive-msg {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            font-size: 18px; color: #00ffff; text-shadow: 0 0 10px #00ffff;
            background: rgba(0, 20, 40, 0.8); padding: 10px 20px; border: 1px solid cyan;
            display: none; z-index: 30;
        }

        /* 暫停/開始菜單 */
        #blocker {
            position: absolute; top:0; left:0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #ffffff; z-index: 999;
        }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      { "imports": { "three": "https://unpkg.com/three@0.154.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/" } }
    </script>
</head>
<body>
    
    <div id="screen-overlay"></div>
    <div id="scanlines"></div>

    <div id="interactive-msg">按 [E] 拾取</div>
    <div id="crosshair-wrapper"><div id="crosshair"></div></div>

    <div id="boss-tracker">
        <div class="boss-hud-inner">
            <div class="boss-header"><span>THREAT DETECTED</span><span>Lvl.<span id="boss-lvl-ui">1</span></span></div>
            <div class="boss-name">HELL KEEPER</div>
            <div id="boss-hp-track-bg"><div id="boss-hp-track-fill"></div></div>
            <div id="boss-dist">DIST: 24m</div>
        </div>
        <div id="boss-line"></div>
    </div>
    
    <div id="hud">
        <div class="hud-top-center">
            <div class="hud-panel score-box">
                <span style="font-size:12px; color:#aaa;">SCORE</span><br>
                <span id="score-val" style="font-size:24px; color:#fff;">0</span>
            </div>
            <div id="boss-warning">⚠️ BOSS APPROACHING ⚠️</div>
        </div>

        <div class="hud-panel hud-bottom-left">
            <div class="hp-segment">
                <span class="hud-label">VITALS</span>
                <span class="hud-value-big"><span id="hp-text">100</span>%</span>
            </div>
            <div id="hp-bar-container"><div id="hp-bar-fill"></div></div>
        </div>

        <div class="hud-panel hud-bottom-right">
            <div class="hud-label">AMMUNITION</div>
            <div id="ammo-val">12</div>
            <div class="hud-label" style="font-size:10px;">RESERVE: <span id="ammo-reserve">36</span></div>
            <div id="weapon-type">Assault Rifle</div>
        </div>
    </div>
    
    <div id="blocker">
        <div style="text-align: center; cursor: pointer;" id="start-btn">
            <h1 style="color:red; font-size:60px; margin:0; text-shadow: 0 0 20px red;">GRAVEYARD PROTOCOL</h1>
            <p style="font-size: 20px; color: cyan;">點擊畫面啟動系統</p>
            <br>
            <div style="border: 1px solid #555; padding: 20px; background: rgba(255,255,255,0.1);">
                <p>WASD 移動 | 空白鍵 跳躍 | R 換彈 | <b>E 拾取</b></p>
                <p style="color: #ff5555;">警告：每 400 分將出現高等級威脅</p>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 變數宣告 ---
        let camera, scene, renderer, controls;
        let raycaster;
        const clock = new THREE.Clock();
        
        // 遊戲狀態
        const player = {
            hp: 100, maxHp: 100,
            ammo: 12, maxMag: 12, reserveAmmo: 36,
            damage: 34, isSuperWeapon: false,
            canShoot: true, isReloading: false,
            score: 0,
            difficultyLevel: 1 
        };

        // Boss 狀態
        let bossState = {
            active: false,
            unit: null,
            nextSpawnScore: 400,
            count: 0 // 已生成幾次
        };

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let lastStepTime = 0; 
        
        let enemyUnits = []; 
        let dropItems = []; 
        let focusItem = null; 
        let lastShootTime = 0;
        let playerWeaponGroup; 
        
        let floorMaterial, stoneMaterial, woodMaterial, ammoMat, weaponDropMat;
        let normalGunMat, superGunMat; 

        // UI 元素
        const hpFill = document.getElementById('hp-bar-fill');
        const hpText = document.getElementById('hp-text');
        const ammoValEl = document.getElementById('ammo-val');
        const ammoResEl = document.getElementById('ammo-reserve');
        const weaponTypeEl = document.getElementById('weapon-type');
        const scoreValEl = document.getElementById('score-val');
        const bossWarning = document.getElementById('boss-warning');
        const interactiveMsg = document.getElementById('interactive-msg');
        const blocker = document.getElementById('blocker');
        const crosshair = document.getElementById('crosshair');
        
        // Boss UI 元素
        const bossTracker = document.getElementById('boss-tracker');
        const bossHpFill = document.getElementById('boss-hp-track-fill');
        const bossDistEl = document.getElementById('boss-dist');
        const bossLvlUi = document.getElementById('boss-lvl-ui');

        // --- 音效引擎 ---
        const SoundGen = {
            ctx: null, masterGain: null, musicNodes: [], creepyInterval: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5; 
                this.masterGain.connect(this.ctx.destination);
                this.startContinuousMusic();
            },
            playTone: function(freq, type, duration, vol, slideTo = null) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain); gain.connect(this.masterGain);
                osc.start(); osc.stop(this.ctx.currentTime + duration);
            },
            playNoise: function(duration, vol, filterFreq = null) {
                if (!this.ctx) return;
                const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
                const src = this.ctx.createBufferSource(); src.buffer = buf;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                if (filterFreq) {
                    const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = filterFreq;
                    src.connect(f); f.connect(gain);
                } else src.connect(gain);
                gain.connect(this.masterGain); src.start();
            },
            startContinuousMusic: function() {
                if (!this.ctx) return;
                this.stopMusic();
                const bassOsc = this.ctx.createOscillator(); bassOsc.type = 'sawtooth'; bassOsc.frequency.value = 55;
                const bassGain = this.ctx.createGain(); bassGain.gain.value = 0.15;
                const bassFilter = this.ctx.createBiquadFilter(); bassFilter.type = 'lowpass'; bassFilter.frequency.value = 150;
                bassOsc.connect(bassFilter); bassFilter.connect(bassGain); bassGain.connect(this.masterGain);
                bassOsc.start(); this.musicNodes.push(bassOsc);
                
                [110, 130.81, 164.81].forEach((freq) => {
                    const osc = this.ctx.createOscillator(); osc.type = 'triangle'; osc.frequency.value = freq; osc.detune.value = (Math.random()-0.5)*10;
                    const gain = this.ctx.createGain(); gain.gain.value = 0.08;
                    const lfo = this.ctx.createOscillator(); lfo.frequency.value = 0.1 + Math.random()*0.1;
                    const lfoGain = this.ctx.createGain(); lfoGain.gain.value = 0.02;
                    lfo.connect(lfoGain); lfoGain.connect(gain.gain); lfo.start(); this.musicNodes.push(lfo);
                    osc.connect(gain); gain.connect(this.masterGain); osc.start(); this.musicNodes.push(osc);
                });

                this.creepyInterval = setInterval(() => {
                    if(Math.random() > 0.65) return;
                    const type = Math.random() > 0.5 ? 'sine' : 'sawtooth';
                    const freq = 300 + Math.random() * 800;
                    const dur = 2 + Math.random() * 3;
                    this.playTone(freq, type, dur, 0.05, freq*0.5);
                }, 3500);
            },
            stopMusic: function() {
                this.musicNodes.forEach(n => { try{n.stop();n.disconnect();}catch(e){} });
                this.musicNodes = [];
                if(this.creepyInterval) clearInterval(this.creepyInterval);
            },
            shoot: function(isSuper) { this.playTone(isSuper?800:400, 'sawtooth', 0.15, 0.2, isSuper?100:50); this.playNoise(0.1, 0.3); },
            empty: function() { this.playTone(800, 'square', 0.05, 0.1); },
            reload: function() { setTimeout(()=>this.playTone(600,'square',0.1,0.1),0); setTimeout(()=>this.playTone(800,'square',0.1,0.1),400); setTimeout(()=>this.playTone(500,'sine',0.2,0.1),1000); },
            pickup: function() { this.playTone(400, 'sine', 0.1, 0.2); setTimeout(()=>this.playTone(600,'sine',0.2,0.2), 100); },
            footstep: function() { this.playNoise(0.05, 0.1, 200); },
            bossSpawn: function() { this.playTone(50, 'sawtooth', 3, 0.8, 20); this.playNoise(2, 0.5); } 
        };

        // --- 紋理生成 ---
        function generateTexture(type) {
            const s = 512; const c = document.createElement('canvas'); c.width = s; c.height = s; const ctx = c.getContext('2d');
            if (type === 'grass') { ctx.fillStyle = '#051105'; ctx.fillRect(0,0,s,s); }
            if (type === 'stone') { ctx.fillStyle = '#222'; ctx.fillRect(0,0,s,s); }
            if (type === 'wood') { ctx.fillStyle = '#110500'; ctx.fillRect(0,0,s,s); }
            if (type === 'ammo') ctx.fillStyle = '#004400';
            if (type === 'gold') ctx.fillStyle = '#665500';
            
            if(type.includes('gun')) {
                ctx.fillStyle = type==='gun_super' ? '#aa8800' : '#334'; ctx.fillRect(0,0,s,s);
                return new THREE.CanvasTexture(c);
            }
            
            // 雜訊細節
            for(let i=0; i<4000; i++) {
                const x = Math.random()*s, y = Math.random()*s, w = Math.random()*3+1;
                if(type === 'grass') { ctx.fillStyle = Math.random()<0.5?'#0a220a':'#0f2f0f'; ctx.fillRect(x,y,w,w); }
                else if(type === 'stone') { ctx.fillStyle = Math.random()<0.5?'#111':'#333'; ctx.fillRect(x,y,w*2,w*2); }
                else if(type === 'ammo') { ctx.fillStyle = '#0f0'; if(i<50) ctx.fillRect(50, i*10, 400, 5); }
                else if(type === 'gold') { ctx.fillStyle = '#fd0'; ctx.fillRect(x,y,2,2); }
            }
            const t = new THREE.CanvasTexture(c); t.wrapS = t.wrapT = THREE.RepeatWrapping; return t;
        }

        // --- 修正過的槍械模型函數 ---
        function createComplexGunModel(material) {
            const g = new THREE.Group();
            
            // 槍身
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 1.2), material); 
            g.add(body);
            
            // 槍管
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.5, 12), material);
            barrel.rotation.x = Math.PI/2;
            barrel.position.set(0, 0.2, -1); 
            g.add(barrel);
            
            // 能量條 (發光)
            const glow = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.1, 0.8), new THREE.MeshBasicMaterial({color:0x00ff00}));
            glow.position.set(0.16, 0.1, -0.2); 
            glow.name = "glowBar"; 
            g.add(glow);
            
            // 調整到視野適合的位置 (修正了這裡)
            g.position.set(0.4, -0.4, -0.8); 
            return g;
        }

        // --- 初始化 ---
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020202);
            scene.fog = new THREE.FogExp2(0x020202, 0.008); 

            const ambient = new THREE.AmbientLight(0x333344, 0.4); scene.add(ambient);
            const moon = new THREE.DirectionalLight(0xaaccff, 0.3); moon.position.set(50,100,50); scene.add(moon);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.y = 12;

            // 手電筒
            const pl = new THREE.SpotLight(0xffffff, 80, 200, 0.6, 0.5);
            pl.position.set(0,0,0); pl.target.position.set(0,0,-1);
            camera.add(pl); camera.add(pl.target);

            // 武器材質與生成
            normalGunMat = new THREE.MeshStandardMaterial({map: generateTexture('gun_normal'), roughness: 0.5});
            superGunMat = new THREE.MeshStandardMaterial({map: generateTexture('gun_super'), roughness: 0.2, metalness: 1, emissive: 0xaa4400, emissiveIntensity: 0.5});
            
            playerWeaponGroup = createComplexGunModel(normalGunMat);
            camera.add(playerWeaponGroup); // 將槍添加到相機

            controls = new PointerLockControls(camera, document.body);
            
            const startBtn = document.getElementById('start-btn');
            startBtn.addEventListener('click', () => { 
                controls.lock(); 
                if(!SoundGen.ctx) SoundGen.init(); else if(SoundGen.ctx.state === 'suspended') SoundGen.ctx.resume();
            });
            controls.addEventListener('lock', () => { blocker.style.display = 'none'; });
            controls.addEventListener('unlock', () => { if(player.hp>0) blocker.style.display = 'flex'; });

            scene.add(controls.getObject());

            // 事件
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);

            raycaster = new THREE.Raycaster();

            // 材質
            const gTex = generateTexture('grass'); gTex.repeat.set(50,50);
            floorMaterial = new THREE.MeshStandardMaterial({map: gTex, roughness: 0.9});
            stoneMaterial = new THREE.MeshStandardMaterial({map: generateTexture('stone'), roughness: 0.7});
            woodMaterial = new THREE.MeshStandardMaterial({map: generateTexture('wood'), roughness: 0.9});
            ammoMat = new THREE.MeshStandardMaterial({color: 0x00ff00, map: generateTexture('ammo'), emissive: 0x002200});
            weaponDropMat = new THREE.MeshStandardMaterial({color: 0xffd700, map: generateTexture('gold'), emissive: 0x443300, metalness:1});

            createEnvironment();
            
            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            updateUI();
        }

        // --- 核心邏輯 ---

        function updateUI() {
            hpText.innerText = Math.floor(player.hp);
            hpFill.style.width = Math.max(0, player.hp) + '%';
            ammoValEl.innerText = player.ammo;
            ammoResEl.innerText = player.reserveAmmo;
            scoreValEl.innerText = player.score;
            
            ammoValEl.style.color = player.ammo <= 3 ? 'red' : '#ffff00';
            
            if (player.ammo === 0 && player.reserveAmmo > 0) {
                interactiveMsg.style.display = 'block';
                interactiveMsg.innerText = "警告：彈藥耗盡 - 按 [R] 裝填";
                interactiveMsg.style.color = "red";
                interactiveMsg.style.borderColor = "red";
            } else if (!focusItem) {
                interactiveMsg.style.display = 'none';
            }
        }

        function checkBossSpawn() {
            if (player.score >= bossState.nextSpawnScore && !bossState.active) {
                spawnBoss();
                bossState.nextSpawnScore += 400; 
            }
        }

        function reloadWeapon() {
            if (player.isReloading || player.ammo === player.maxMag || player.reserveAmmo === 0) return;
            player.isReloading = true;
            crosshair.classList.add('reloading');
            SoundGen.reload();
            
            const startY = -0.4; // 修正動畫起始點
            let p = 0;
            const interval = setInterval(() => {
                p += 0.05;
                if(p < 0.5) { playerWeaponGroup.rotation.x -= 0.1; playerWeaponGroup.position.y -= 0.05; }
                else if(p > 1.0) { playerWeaponGroup.rotation.x += 0.1; playerWeaponGroup.position.y += 0.05; }

                if(p >= 1.5) {
                    clearInterval(interval);
                    const needed = player.maxMag - player.ammo;
                    const take = Math.min(needed, player.reserveAmmo);
                    player.ammo += take; player.reserveAmmo -= take;
                    
                    playerWeaponGroup.rotation.x = 0; playerWeaponGroup.position.y = startY;
                    player.isReloading = false;
                    crosshair.classList.remove('reloading');
                    updateUI();
                }
            }, 50);
        }

        function createEnvironment() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000).rotateX(-Math.PI/2), floorMaterial);
            floor.receiveShadow = true; scene.add(floor);
            
            const tGeo = new THREE.BoxGeometry(4, 7, 1);
            const trGeo = new THREE.ConeGeometry(3, 20, 5);
            for(let i=0; i<250; i++) {
                const x = (Math.random()-0.5)*800, z = (Math.random()-0.5)*800;
                if(Math.abs(x)<50 && Math.abs(z)<50) continue;
                
                const isTree = Math.random() < 0.2;
                const m = new THREE.Mesh(isTree?trGeo:tGeo, isTree?woodMaterial:stoneMaterial);
                m.position.set(x, isTree?10:3.5, z);
                if(!isTree) m.rotation.y = (Math.random()-0.5);
                scene.add(m);
            }
        }

        // --- 敵人生成 ---
        
        function spawnGhost() {
            const max = 10 + Math.floor(player.score/200);
            if (enemyUnits.length > max) return;

            const g = new THREE.Group();
            const body = new THREE.Mesh(new THREE.ConeGeometry(3, 8, 8, 1, true), 
                new THREE.MeshStandardMaterial({color: 0x88ffff, emissive: 0x004444, transparent: true, opacity: 0.7, side: THREE.DoubleSide}));
            body.position.y = 4; g.add(body);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(2), body.material);
            head.position.y = 8; g.add(head);

            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color:0xff0000}));
            const le = eye.clone(); le.position.set(-0.8, 8.5, 1.5); g.add(le);
            const re = eye.clone(); re.position.set(0.8, 8.5, 1.5); g.add(re);

            spawnUnit(g, 100 + (player.score/20), 12 + Math.random()*8, 'normal');
        }

        function spawnBoss() {
            bossState.active = true;
            bossState.count++;
            
            SoundGen.bossSpawn();
            bossWarning.style.display = 'block';
            setTimeout(() => bossWarning.style.display = 'none', 4000);

            const level = bossState.count;
            const multiplier = 1 + (level * 0.5); 

            const g = new THREE.Group();
            
            const mat = new THREE.MeshStandardMaterial({
                color: 0x660000, roughness: 0.3, metalness: 0.8, 
                emissive: 0x550000, emissiveIntensity: 0.8
            });
            
            const body = new THREE.Mesh(new THREE.CylinderGeometry(5*multiplier, 3*multiplier, 15*multiplier, 6), mat);
            body.position.y = 7.5*multiplier; g.add(body);
            
            const head = new THREE.Mesh(new THREE.DodecahedronGeometry(4*multiplier), mat);
            head.position.y = 16*multiplier; g.add(head);
            
            const eyeGeo = new THREE.BoxGeometry(1*multiplier, 0.5*multiplier, 1*multiplier);
            const eyeMat = new THREE.MeshBasicMaterial({color: 0xff0000});
            const le = new THREE.Mesh(eyeGeo, eyeMat); le.position.set(-2*multiplier, 16*multiplier, 3*multiplier);
            const re = new THREE.Mesh(eyeGeo, eyeMat); re.position.set(2*multiplier, 16*multiplier, 3*multiplier);
            g.add(le); g.add(re);

            const halo = new THREE.Mesh(new THREE.TorusGeometry(6*multiplier, 0.5, 16, 50), new THREE.MeshBasicMaterial({color:0xff0000}));
            halo.rotation.x = Math.PI/2; halo.position.y = 22*multiplier;
            halo.name = "halo"; 
            g.add(halo);

            const light = new THREE.PointLight(0xff0000, 5, 40*multiplier);
            light.position.y = 10;
            g.add(light);

            const hp = 800 * multiplier;
            const speed = (18 + (level * 2)); 
            
            const unit = spawnUnit(g, hp, speed, 'boss');
            unit.maxHp = hp;
            bossState.unit = unit;

            bossLvlUi.innerText = level;
            bossTracker.style.display = 'block';
        }

        function spawnUnit(group, hp, speed, type) {
            const angle = Math.random() * Math.PI * 2;
            const rad = 100 + Math.random() * 100;
            group.position.set(
                controls.getObject().position.x + Math.cos(angle)*rad,
                2,
                controls.getObject().position.z + Math.sin(angle)*rad
            );
            scene.add(group);
            
            const unit = { group: group, hp: hp, speed: speed, type: type, floatOffset: Math.random()*100 };
            enemyUnits.push(unit);
            return unit;
        }

        function spawnDrop(pos) {
            const isWeapon = Math.random() < 0.2;
            const mesh = new THREE.Mesh(
                isWeapon ? new THREE.BoxGeometry(1,1,4) : new THREE.BoxGeometry(2,2,2),
                isWeapon ? weaponDropMat : ammoMat
            );
            mesh.userData = { 
                type: isWeapon?'weapon':'ammo', 
                label: isWeapon?'高能武器':'彈藥箱',
                rotateSpeed: isWeapon?3:1 
            };
            mesh.position.copy(pos); mesh.position.y = 3;
            scene.add(mesh); dropItems.push(mesh);
        }

        // --- 互動與射擊 ---
        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if(canJump) velocity.y += 250; canJump = false; break;
                case 'KeyR': reloadWeapon(); break;
                case 'KeyE': tryPickup(); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        function onMouseDown() {
            if(!controls.isLocked || player.hp<=0 || player.isReloading) return;
            if(player.ammo <= 0) { SoundGen.empty(); reloadWeapon(); return; }
            if(performance.now() - lastShootTime < 150) return;
            lastShootTime = performance.now();

            SoundGen.shoot(player.isSuperWeapon);
            player.ammo--; updateUI();
            
            // 後座力
            playerWeaponGroup.position.z += 0.2; // 修正後座力幅度
            setTimeout(()=> playerWeaponGroup.position.z -= 0.2, 80);

            const flash = new THREE.PointLight(player.isSuperWeapon?0xffaa00:0x00ffff, 5, 20);
            flash.position.set(0.4, -0.4, -2); camera.add(flash); setTimeout(()=>camera.remove(flash), 50);

            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const targets = [];
            enemyUnits.forEach(u => u.group.children.forEach(c => targets.push(c)));
            const intersects = raycaster.intersectObjects(targets);

            if(intersects.length > 0) {
                const hitObj = intersects[0].object;
                const parent = hitObj.parent;
                const idx = enemyUnits.findIndex(u => u.group === parent);
                if(idx > -1) hitEnemy(idx);
            }
        }

        function hitEnemy(idx) {
            const unit = enemyUnits[idx];
            unit.hp -= player.damage;
            
            unit.group.children.forEach(m => {
                if(m.material && m.material.emissive) {
                    const old = m.material.emissive.getHex();
                    m.material.emissive.setHex(0xffffff);
                    setTimeout(()=> m.material.emissive.setHex(old), 50);
                }
            });

            if(unit.hp <= 0) {
                if (unit.type === 'boss') {
                    bossState.active = false;
                    bossState.unit = null;
                    bossTracker.style.display = 'none';
                    player.score += 1000;
                    spawnDrop(unit.group.position); 
                    spawnDrop(unit.group.position); 
                } else {
                    player.score += 100;
                    if(Math.random()<0.3) spawnDrop(unit.group.position);
                }
                
                scene.remove(unit.group);
                enemyUnits.splice(idx, 1);
                checkBossSpawn(); 
                updateUI();
            }
        }

        function tryPickup() {
            if(focusItem) {
                const idx = dropItems.indexOf(focusItem);
                if(idx > -1) {
                    SoundGen.pickup();
                    const item = dropItems[idx];
                    if(item.userData.type === 'ammo') {
                        player.reserveAmmo += 20;
                    } else {
                        player.damage = 100; player.isSuperWeapon = true;
                        weaponTypeEl.innerText = "PLASMA DISRUPTOR";
                        weaponTypeEl.style.color = "gold";
                        playerWeaponGroup.children.forEach(c => {
                            if(c.isMesh && c.name !== 'glowBar') c.material = superGunMat;
                            if(c.name === 'glowBar') c.material.color.setHex(0xff0000);
                        });
                    }
                    scene.remove(item); dropItems.splice(idx, 1);
                    focusItem = null; updateUI();
                }
            }
        }

        function updateBossUI() {
            if (!bossState.active || !bossState.unit) {
                bossTracker.style.display = 'none';
                return;
            }

            const boss = bossState.unit;
            
            const hpPercent = Math.max(0, (boss.hp / boss.maxHp) * 100);
            bossHpFill.style.width = hpPercent + '%';

            const headPos = boss.group.position.clone();
            headPos.y += (boss.type === 'boss' ? 25 : 10); 
            
            headPos.project(camera);

            if (headPos.z < 1) {
                const x = (headPos.x * .5 + .5) * window.innerWidth;
                const y = (-(headPos.y * .5) + .5) * window.innerHeight;

                bossTracker.style.display = 'block';
                bossTracker.style.transform = `translate(${x - 110}px, ${y - 120}px)`;
                
                const dist = Math.floor(boss.group.position.distanceTo(camera.position));
                bossDistEl.innerText = `DIST: ${dist}m`;
                
                if (hpPercent < 30) {
                    bossHpFill.style.backgroundColor = '#ffcc00'; 
                    if(Math.random() > 0.8) bossTracker.style.opacity = 0.5; else bossTracker.style.opacity = 1; 
                } else {
                    bossHpFill.style.backgroundColor = '#ff0000';
                    bossTracker.style.opacity = 1;
                }
            } else {
                bossTracker.style.display = 'none';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = performance.now();

            if (controls.isLocked && player.hp > 0) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);
                
                if (controls.getObject().position.y < 12) {
                    velocity.y = 0; controls.getObject().position.y = 12; canJump = true;
                    if((moveForward||moveBackward||moveLeft||moveRight) && time-lastStepTime > 400) {
                        SoundGen.footstep(); lastStepTime = time;
                    }
                }

                const pPos = controls.getObject().position;
                enemyUnits.forEach(u => {
                    u.group.lookAt(pPos.x, u.group.position.y, pPos.z);
                    const dist = u.group.position.distanceTo(pPos);
                    
                    if (dist > (u.type==='boss'?15:8)) {
                        const dir = new THREE.Vector3().subVectors(pPos, u.group.position).normalize();
                        u.group.position.add(dir.multiplyScalar(u.speed * delta));
                    } else {
                        player.hp -= delta * (u.type==='boss'?50:20);
                        updateUI();
                        if(player.hp <= 0) {
                            controls.unlock();
                            blocker.style.display = 'flex';
                            SoundGen.stopMusic();
                            document.getElementById('instructions').innerText = "MISSION FAILED";
                        }
                    }
                    if(u.type === 'boss') {
                        const halo = u.group.getObjectByName('halo');
                        if(halo) { halo.rotation.z += delta * 2; halo.rotation.x = Math.PI/2 + Math.sin(time*0.002)*0.5; }
                    }
                });

                let closest = 10, target = null;
                dropItems.forEach(i => {
                    i.rotation.y += delta * i.userData.rotateSpeed;
                    i.position.y = 3 + Math.sin(time*0.003)*0.5;
                    const d = pPos.distanceTo(i.position);
                    if(d < 10 && d < closest) { closest = d; target = i; }
                });
                focusItem = target;
                if(focusItem) {
                    interactiveMsg.style.display = 'block';
                    interactiveMsg.style.color = '#00ffff'; interactiveMsg.style.borderColor = 'cyan';
                    interactiveMsg.innerText = `[E] 拾取 ${focusItem.userData.label}`;
                } else if (player.ammo > 0) {
                    interactiveMsg.style.display = 'none';
                }

                // --- 修正後的生成邏輯 ---
                if (!bossState.active) {
                    checkBossSpawn(); // 檢查分數是否到了 BOSS 點
                    
                    // 只有 Boss 不在的時候才生成普通怪
                    if (Math.random() < 0.02 && enemyUnits.length < 10) {
                        spawnGhost();
                    }
                } else {
                    // Boss 在場時，偶爾生成干擾小怪
                    if (Math.random() < 0.005 && enemyUnits.length < 5) {
                        spawnGhost();
                    }
                }

                updateBossUI();
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>