<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dino Dash DX: 修正版</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-sky: #87CEEB;
            --bg-ground: #f0e68c;
            --console-color: #e0e0e0;
            --text-color: #333;
            --accent-color: #555;
        }
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(to bottom, var(--bg-sky) 0%, var(--bg-sky) 60%, var(--bg-ground) 60%, var(--bg-ground) 100%);
            font-family: 'Press Start 2P', monospace;
            box-sizing: border-box;
            user-select: none;
            overflow: hidden; /* 防止滾動 */
        }

        #game-container {
            background-color: var(--console-color);
            padding: 20px 30px 40px 30px;
            border-radius: 15px;
            box-shadow: 
                0 10px 20px rgba(0,0,0,0.3),
                inset 0 -5px 15px rgba(255,255,255,0.5);
            border: 4px solid #b0b0b0;
            text-align: center;
            width: 100%;
            max-width: 860px;
        }

        #hud-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: var(--text-color);
            font-size: 12px;
            text-transform: uppercase;
            border-bottom: 3px solid var(--accent-color);
            padding-bottom: 10px;
        }

        h1 {
            margin: 0;
            font-size: 14px;
            color: var(--accent-color);
            text-shadow: 2px 2px 0px #fff;
        }

        .canvas-wrapper {
            border: 6px solid #333;
            border-radius: 4px;
            background-color: #000;
            padding: 2px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            overflow: hidden;
            position: relative;
        }

        #gameCanvas {
            background-color: #f7f7f7;
            display: block;
            width: 100%;
            height: auto; /* 保持比例 */
            aspect-ratio: 800 / 250;
            image-rendering: pixelated; 
        }

        #controls-hint {
            margin-top: 15px;
            font-size: 10px;
            color: var(--accent-color);
            line-height: 1.6;
        }

        .highlight { color: #d32f2f; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="hud-panel">
            <h1>DINO ADVENTURE</h1>
            <div>
                SCORE: <span id="scoreText" class="highlight">0</span> | 
                HI: <span id="highScoreText">0</span>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="250"></canvas>
        </div>
        
        <div id="controls-hint">
            <p>[空白鍵] 或 [↑] 跳躍 &nbsp;|&nbsp; [↓] 蹲下</p>
            <p style="color: #666; font-size: 8px;">(點擊畫面開始/跳躍，按住螢幕下半部蹲下)</p>
        </div>
    </div>

<script>
/**
 * AUDIO SYSTEM
 */
const AudioSys = {
    ctx: null,
    isPlaying: false,
    musicTimer: null,
    musicNoteIndex: 0,
    
    init: function() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
    },

    playTone: function(freq, duration, type = 'square', vol = 0.1) {
        if (!this.ctx) return;
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        } catch(e) { console.error(e); }
    },

    sfx: {
        jump: () => AudioSys.playTone(600, 0.1, 'square', 0.1),
        score: () => {
            AudioSys.playTone(1000, 0.1, 'sine', 0.2);
            setTimeout(() => AudioSys.playTone(1500, 0.2, 'sine', 0.2), 100);
        },
        die: () => AudioSys.playTone(150, 0.5, 'sawtooth', 0.2)
    },

    startMusic: function() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.musicNoteIndex = 0;
        const melody = [330, 330, 330, 0, 330, 330, 330, 0, 330, 392, 261, 293, 330, 0, 349, 349, 349, 349, 349, 330, 330, 330, 330, 293, 293, 330, 293, 392];
        
        if (this.musicTimer) clearInterval(this.musicTimer);

        this.musicTimer = setInterval(() => {
            if (!this.isPlaying || isGameOver) {
                clearInterval(this.musicTimer);
                return;
            }
            const note = melody[this.musicNoteIndex];
            if (note > 0) this.playTone(note, 0.15, 'triangle', 0.05);
            this.musicNoteIndex = (this.musicNoteIndex + 1) % melody.length;
        }, 200);
    },

    stopMusic: function() {
        this.isPlaying = false;
        clearInterval(this.musicTimer);
    }
};

/**
 * GAME LOGIC
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

// 關鍵修正：初始狀態設為 true，這樣第一次按鍵才會觸發 start()
let isGameOver = true; 
let score = 0;
let highScore = 0;
let baseGameSpeed = 5;
let gameSpeed = baseGameSpeed;
let frames = 0;
let nextObstacleTimer = 0;
const groundY = 220; 
let animationId = null; // 用來管理 requestAnimationFrame

const dino = {
    x: 50, y: groundY - 50, width: 50, height: 50, dy: 0, jumpForce: 13, grounded: false, ducking: false,
    colors: { body: '#4CAF50', belly: '#81C784', eye: '#FFF', leg: '#388E3C' },
    draw: function() {
        let drawH = this.ducking ? 30 : 50;
        let drawY = this.ducking ? this.y + 20 : this.y;
        ctx.fillStyle = this.colors.body;
        if (this.ducking) {
            ctx.fillRect(this.x, drawY, 55, 30);
            ctx.fillStyle = this.colors.belly; ctx.fillRect(this.x + 5, drawY + 20, 35, 10);
            ctx.fillStyle = this.colors.eye; ctx.fillRect(this.x + 40, drawY + 5, 8, 8);
            ctx.fillStyle = "black"; ctx.fillRect(this.x + 45, drawY + 7, 3, 3);
        } else {
            ctx.fillRect(this.x + 10, drawY + 20, 30, 25);
            ctx.fillRect(this.x + 25, drawY, 25, 25);
            ctx.fillRect(this.x + 45, drawY + 15, 10, 10);
            ctx.fillStyle = this.colors.belly; ctx.fillRect(this.x + 10, drawY + 35, 25, 10);
            ctx.fillStyle = this.colors.eye; ctx.fillRect(this.x + 35, drawY + 5, 8, 8);
            ctx.fillStyle = "black"; ctx.fillRect(this.x + 40, drawY + 7, 3, 3);
        }
        ctx.fillStyle = this.colors.leg;
        let legOffset = (this.grounded && frames % 16 < 8) ? 5 : 0;
        let legY = this.ducking ? drawY + 30 : drawY + 45;
        ctx.fillRect(this.x + 15, legY - legOffset, 10, 10 + legOffset);
        ctx.fillRect(this.x + 30, legY + legOffset - 5, 10, 10 - legOffset + 5);
    },
    jump: function() {
        if (this.grounded && !this.ducking) {
            this.dy = -this.jumpForce;
            this.grounded = false;
            AudioSys.sfx.jump();
        }
    },
    update: function() {
        this.y += this.dy;
        if (this.y + this.height < groundY) { this.dy += 0.8; this.grounded = false; } 
        else { this.dy = 0; this.grounded = true; this.y = groundY - this.height; }
        this.draw();
    }
};

const obstacles = [];
class Cactus {
    constructor() {
        this.type = 'cactus';
        this.groupSize = Math.floor(Math.random() * 3) + 1;
        this.w = 25 * this.groupSize; 
        this.h = 45 + Math.random() * 15;
        this.x = canvas.width;
        this.y = groundY - this.h;
        this.color = '#2E7D32';
    }
    draw() {
        ctx.fillStyle = this.color;
        for(let i=0; i<this.groupSize; i++) {
            let offsetX = i * 25;
            let cactusH = this.h - (i%2)*10;
            ctx.fillRect(this.x + offsetX, groundY - cactusH, 20, cactusH);
            ctx.fillStyle = '#1B5E20'; ctx.fillRect(this.x + offsetX + 4, groundY - cactusH + 5, 2, cactusH-10);
            ctx.fillStyle = this.color;
        }
    }
    update() { this.x -= gameSpeed; this.draw(); }
    getHitbox() { return { x: this.x + 5, y: this.y + 5, w: (this.groupSize * 25) - 10, h: this.h - 10 }; }
}

class Bird {
    constructor() {
        this.type = 'bird';
        this.w = 40; this.h = 30;
        this.x = canvas.width;
        this.y = (Math.random() > 0.7) ? groundY - 75 : groundY - 40;
        this.color = '#1E88E5';
    }
    draw() {
        ctx.fillStyle = this.color;
        let flap = Math.floor(frames / 10) % 2 === 0;
        ctx.fillRect(this.x, this.y + 10, 40, 15);
        ctx.fillRect(this.x - 10, this.y + 5, 15, 15);
        ctx.fillStyle = '#FFA000'; ctx.fillRect(this.x - 15, this.y + 10, 5, 5);
        ctx.fillStyle = '#1565C0';
        ctx.fillRect(this.x + 10, flap ? this.y - 10 : this.y + 10, 20, 20);
    }
    update() { this.x -= (gameSpeed + 1.5); this.draw(); }
    getHitbox() { return { x: this.x, y: this.y + 5, w: this.w, h: this.h - 5 }; }
}

function spawnObstacle() {
    nextObstacleTimer--;
    if (nextObstacleTimer <= 0) {
        let birdChance = Math.min(score / 2000, 0.5); 
        obstacles.push((score > 300 && Math.random() < birdChance) ? new Bird() : new Cactus());
        let minFrames = 60; let maxFrames = 140;
        if (gameSpeed > 10) maxFrames = 100;
        nextObstacleTimer = Math.floor(Math.random() * (maxFrames - minFrames) + minFrames);
    }
}

function drawEnvironment() {
    ctx.fillStyle = '#8D6E63'; ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
    ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY);
    ctx.lineWidth = 4; ctx.strokeStyle = '#5D4037'; ctx.stroke();
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    let cloudX = (frames * 0.5) % (canvas.width + 200) - 100;
    ctx.fillRect(canvas.width - cloudX, 50, 60, 20);
}

function update() {
    if (isGameOver) return;
    animationId = requestAnimationFrame(update);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawEnvironment();
    frames++; score++;
    
    if (gameSpeed < 18) gameSpeed += 0.0005;
    
    let displayScore = Math.floor(score / 10);
    if (displayScore > 0 && displayScore % 100 === 0 && score % 10 === 0) AudioSys.sfx.score();
    document.getElementById('scoreText').innerText = displayScore;
    
    dino.update();
    spawnObstacle();
    
    for (let i = 0; i < obstacles.length; i++) {
        let obs = obstacles[i];
        obs.update();
        if (obs.x + 100 < 0) { obstacles.splice(i, 1); i--; }
        
        let hitBox = obs.getHitbox();
        let dinoBox = {
            x: dino.x + 5,
            y: dino.ducking ? dino.y + 20 : dino.y + 5,
            w: dino.ducking ? 50 : dino.width - 15,
            h: dino.ducking ? 30 : dino.height - 15
        };
        if (dinoBox.x < hitBox.x + hitBox.w && dinoBox.x + dinoBox.w > hitBox.x &&
            dinoBox.y < hitBox.y + hitBox.h && dinoBox.y + dinoBox.h > hitBox.y) {
            gameOver();
        }
    }
}

function start() {
    AudioSys.init();
    AudioSys.startMusic();
    isGameOver = false;
    score = 0;
    gameSpeed = baseGameSpeed;
    obstacles.length = 0;
    dino.y = groundY - dino.height;
    dino.dy = 0;
    dino.grounded = true;
    nextObstacleTimer = 0;
    frames = 0;
    if (animationId) cancelAnimationFrame(animationId);
    update();
}

function gameOver() {
    isGameOver = true;
    AudioSys.stopMusic();
    AudioSys.sfx.die();
    cancelAnimationFrame(animationId); // 停止動畫循環
    
    // 繪製 GameOver 畫面
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = "white"; ctx.textAlign = "center";
    ctx.font = "30px 'Press Start 2P', monospace";
    ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
    ctx.font = "14px 'Press Start 2P', monospace";
    ctx.fillText("PRESS SPACE TO RESTART", canvas.width/2, canvas.height/2 + 50);

    let displayScore = Math.floor(score/10);
    if (displayScore > highScore) {
        highScore = displayScore;
        document.getElementById('highScoreText').innerText = highScore;
    }
}

function handleInput(e) {
    // 確保只回應特定按鍵
    if (e.type === 'keydown' && e.code !== 'Space' && e.code !== 'ArrowUp' && e.code !== 'ArrowDown') return;

    if (e.type === 'keydown') {
        if (e.code === 'Space' || e.code === 'ArrowUp') {
            e.preventDefault();
            if (isGameOver) {
                start();
            } else {
                dino.jump();
            }
        }
        if (e.code === 'ArrowDown') {
            e.preventDefault();
            if (!isGameOver) dino.ducking = true;
        }
    }
    if (e.type === 'keyup' && e.code === 'ArrowDown') dino.ducking = false;
    
    if (e.type === 'touchstart') {
        e.preventDefault();
        if (isGameOver) start();
        else dino.jump();
    }
}

window.addEventListener('keydown', handleInput);
window.addEventListener('keyup', handleInput);
window.addEventListener('touchstart', handleInput, { passive: false });

// 初始等待畫面
ctx.fillStyle = "#333";
ctx.font = "20px 'Press Start 2P', monospace";
ctx.textAlign = "center";
ctx.fillText("PRESS SPACE TO START", canvas.width/2, canvas.height/2);

</script>
</body>
</html>